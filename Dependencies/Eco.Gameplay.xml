<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>Eco.Gameplay</name>
    </assembly>
    <members>
        <member name="M:Eco.Gameplay.Aliases.AliasExtensions.ToUsers(System.Collections.Generic.IEnumerable{Eco.Gameplay.Aliases.IAlias})">
            <summary>Get the full list of users in all these aliases, no repeats.</summary>
        </member>
        <member name="T:Eco.Gameplay.Auth.AuthManager">
            <summary> Class solely responsible for authorization about everything (e.g.: WorldObjects, Plots, GameActions, etc). </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks authorization of a GameAction. Returns success if user is authorized on the WorldObject, if there is one, or all deeds affected if there isn't. </summary>
            <remarks> Also returns success if GameAction doesn't need any access, or if GameAction is NOT issued by a user (for non-user actions like <see cref="T:Eco.Gameplay.GameActions.GlobalTimer" />). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks authorization on a WorldObject. </summary>
            <remarks> Returns success if user is authorized on the AuthComponent, if there is one, or the plot if there isn't. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Shared.Voxel.PlotPos,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks authorization on a position. Returns success if user is authorized on specified plot position. </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Shared.Math.WorldRange,Eco.Gameplay.Players.User,Eco.Shared.Items.AccessType)">
            <summary> Checks authorization for a swath of land (WITHOUT overrides from GameAction). </summary>
            <remarks> Returns success if user is authorized on ALL plots. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.Interactions.InteractionContext,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Helper function to call the correct auth check given a context. </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.GetAuthorizationLevel(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Property.IOwned,Eco.Gameplay.GameActions.GameAction)">
            <summary> Gets the level of authorization a user has over the specified property. <para> Internally checks for GameAction auth overrides. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.ShouldOverrideAuth(Eco.Gameplay.GameActions.GameAction)">
            <summary> Checks if auth should be overriden for target GameAction. <para> e.g.: Auth should be overriden for a GameAction that affects a WorldObject authorized by a Contract. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.GetAuthorizationLevel(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Property.IOwned,Eco.Core.Utils.LazyResult@,Eco.Gameplay.GameActions.GameAction)">
            <summary> Gets the level of authorization an alias has on the specified property.           </summary>
            <remarks> If there's an access override from a GameAction, it is outted as `specialResult`. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(Eco.Gameplay.Property.IOwned,Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Helper function that returns success if alias is authorized on target property. </summary>
            <remarks> Returns the special result if access if overriden from GameAction.              </remarks>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.IsAuthorized(System.Collections.Generic.IEnumerable{Eco.Gameplay.Property.Deed},Eco.Gameplay.Aliases.IAlias,Eco.Shared.Items.AccessType,Eco.Gameplay.GameActions.GameAction)">
            <summary> Helper function that returns success if alias is authorized on ALL specified deeds. </summary>
        </member>
        <member name="M:Eco.Gameplay.Auth.AuthManager.NotAuthed(Eco.Core.Systems.INamed)">
            <summary> The failure result for unauthorized actions. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.BlockTierAttribute">
            <summary> The tier of a block used for room tier calculations. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.Reapable">
            <summary> That can be reaped; ready for reaping. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.Chopable">
            <summary> That can be chopped; ready for chopping. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.Clearable">
            <summary> That can be cleared by a machete; ready for clearing. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.BlockContainer">
            <summary> A contained area of blocks. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainer.#ctor(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.Vector3)">
            <summary> Makes new block container at <paramref name="position" /> (it should be pre-wrapped) and with specified <paramref name="size" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainer.Contains(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Checks if <paramref name="position" /> is within the <see cref="T:Eco.Gameplay.Blocks.BlockContainer" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.BlockContainerManager">
            <summary> Manages contained areas of blocks. Can test if an individual block is in any container. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainerManager.AddBlockContainer(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.Vector3)">
            <summary> Adds <see cref="T:Eco.Gameplay.Blocks.BlockContainer" /> at <paramref name="position" /> with <paramref name="size" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainerManager.RemoveBlockContainer(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.Vector3)">
            <summary> Removes <see cref="T:Eco.Gameplay.Blocks.BlockContainer" /> at <paramref name="position" /> with <paramref name="size" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Blocks.BlockContainerManager.IsBlockContained(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Checks if <paramref name="position" /> contained within any of registered <see cref="T:Eco.Gameplay.Blocks.BlockContainer" /> instances. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.BlockForm.MaterialId">
            <summary> Material ID of material that form is made from. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.BlockForm.BlockTypes">
            <summary> Rotational variants, first being default. They are suppose to go in order: 0 - not rotated, 1 - rotation for 90° and so on. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.BlockForm.Next">
            <summary> Used in case of consecutive blocks, like ramps. TODO: change to ushort? after adding support of nullables to view system. Now -1 represents null </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.IconName">
            <summary> Icon name used by the client to look up the icon in Eco.scene. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.GroupType">
            <summary> The FormGroup-derived type that defines the group this form belongs to. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.MinTier">
            <summary> Minimum tier of hammer needed to use this form. </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.FormType.Group">
            <summary> Form group used for grouping in the UI. </summary>
        </member>
        <member name="T:Eco.Gameplay.Blocks.IconItem">
            <summary>
            Base class for block forms and fills.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Blocks.IconItem.SortOrder">
            <summary> A number used for sorting in lists in the UI. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsExtensions.SetDefaults(Eco.Gameplay.Civics.ElectionProcess)">
            <summary> Values of the provided election process will be replaced with defaults from the config. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.CivicsExtensions.TrySetValueFromConfig(Eco.Gameplay.Civics.ElectionProcess,System.Reflection.PropertyInfo)">
            <summary> Looks for a property with the same name and replaces its value with the one from the config. </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameActionAccumulator">
            <summary>Accumulator to aggregate <see cref="T:Eco.Gameplay.GameActions.GameAction" />'s property every intervalTime seconds.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameActionAccumulator.AddGameActions(Eco.Gameplay.GameActions.AccumulatableAction,Eco.Gameplay.Players.User)">
            <summary>Add <see cref="T:Eco.Gameplay.GameActions.GameAction" /> every time it's need to accumulate.</summary> 
        </member>
        <member name="M:Eco.Gameplay.Civics.GameActionAccumulator.Tick">
            <summary>
            Perform all GameActions which are accumulated and clear the data of last intervalTime seconds.
            Step 1: get copy List of <see cref="F:Eco.Gameplay.Civics.GameActionAccumulator.userGameActionList" /> and clear it
            Step 2: group copied list by user and type
            Step 3: Iterate each group and <see cref="M:Eco.Gameplay.GameActions.AccumulatableAction.AggregateAction(Eco.Gameplay.GameActions.AccumulatableAction)" /> them into one
            Step 4: Perform aggregated Action"/&gt;
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Constitutional.UserCivicDuties.CivicDutiesBySettlement">
            <summary>The civic duties a given user has per-settlement.  If there's nothing in there, they have none.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.CivicDuties">
            <summary>A list of the duties a given user has on a given settlement</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.SettlementDutyData">
            <summary>Stores and share with the client descriptions of how to use each civics world object. One of these is created per-settlement.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Constitutional.CivicDutyManager">
            <summary>Manages the list of things a player can do in a given settlement's government, which is communicated to the player in various places 
            (government panel, on the civics world objects themselves, etc).</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Constitutional.CivicDutyManager.BuildHowToUseEntryForType(Eco.Gameplay.Settlements.Settlement,System.Collections.Generic.Dictionary{System.Type,System.String},System.Type,System.Type)">
            <summary>Describe how to use the given type of civic object, based on the given settlement and constitution.</summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.ConstitutionManager.SettlementToCurrentArticles">
            <summary>All the active articles, from both the constituion and any amendments that modify that list.  Will contain invalid articles too.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.ConstitutionManager.SetConstitution(Eco.Gameplay.Civics.Constitution,Eco.Gameplay.Settlements.Settlement)">
            <summary>Set the constitution for a given settlement</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager">
            <summary> Aggregates given amounts and gets ticked using <see cref="T:Eco.Gameplay.Civics.CivicsPlugin" /> through <see cref="M:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)" /> </summary>
            <inheritdoc cref="T:Eco.Shared.Utils.Singleton`1" />
            <example> Used for <see cref="T:Eco.Gameplay.Economy.WorkParties.WorkParty" /> Pay as you go feature where fraction payments that can get aggregated over <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> time. </example>
            <remarks> This is meant to process transfers in bulk instead of using <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications" /> to avoid extra processing that isn't meant to be done for notifications.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.AddOrUpdateAggregatedAmount(Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount,Eco.Gameplay.Players.User,System.Single)">
            <summary>
            Adds a delayed amount by <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> that should aggregate if there is a value with the same handles already delayed.
            </summary>
            <param name="aggregatedAmountHandler"> The aggregated amount Handler that should be resposible for handling the aggregated value. </param>
            <param name="user"> The target user that the amount should go to. </param>
            <param name="amountDelta"> The difference in aggregated amount that should applied for the given user, for example in WorkParites the payment is calculated with <see cref="T:Eco.Gameplay.Economy.WorkParties.Payment" />, in which the weight change (aggregated amount) is given and then payment is calculated and paid.</param>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.ForceAggregatingAmountsForHandler(Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount)">
            <summary> Forces the remaining aggregate amounts for the given amount handler. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.Tick">
            <summary> When ticked checks if there are aggregate amounts due and pays it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.ApplyAggregatedAmountsGroupAndRemove(System.Collections.Generic.IEnumerable{Eco.Gameplay.Civics.Economy.AggregatedAmount})">
            <summary> Processes out the given group of aggregate amounts and removes it from <see cref="F:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.aggregatedAmounts" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.ProcessAggregatedAmountAndRemove(Eco.Gameplay.Civics.Economy.AggregatedAmount)">
            <summary> Applies handling for the given aggregated amount and removes it from <see cref="F:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager.aggregatedAmounts" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Economy.AggregatedAmount">
            <summary> Holds data for aggregated amount, this is ticked by <see cref="T:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager" /> through <see cref="T:Eco.Gameplay.Civics.CivicsPlugin" />, delay is calculated internally using <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount">
            <summary> Interface meant for handling aggregated amounts using <see cref="T:Eco.Gameplay.Civics.Economy.AggregateUserAmountManager" /> </summary>
            <example> Check <see cref="T:Eco.Gameplay.Economy.WorkParties.WorkParty" /> for an example implementation. </example>
        </member>
        <member name="M:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)">
            <summary> Process the final aggregated amount for the given user. </summary>
            <param name="user">The targeted user reference.</param>
            <param name="amount">The final amount to be applied after aggregating for <see cref="F:Eco.Gameplay.Civics.Economy.AggregatedAmount.Delay" /> seconds</param>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.CanVote(Eco.Gameplay.Players.User,Eco.Shared.Localization.LocStringBuilder)">
            <summary>Check the various things that determine if a user can vote or not. Optionally explain why in a passed string builder.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.SetChoiceRanks(System.Collections.Generic.IEnumerable{Eco.Gameplay.Civics.Elections.ChoiceResults})">
            <summary> Set current election rankings and update SimpleResults based on them. </summary>  
        </member>
        <member name="M:Eco.Gameplay.Civics.Elections.Election.GetTiedElectionResult">
            <summary> Logic for tied election results. <para> Fail result if canceled, Success if there is a winner. </para> </summary>
        </member>
        <member name="P:Eco.Gameplay.Civics.Elections.CivicAction_StartElection.NotifyOnPerform">
            <summary>
            This is overriden to false for this action because this action invokes another global <see cref="M:Eco.Gameplay.Players.Player.OkBox(Eco.Shared.Localization.LocString)" /> that is tailored for elections.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LawUtil.DescribeActiveLawsAtPosition(Eco.Shared.Math.Vector2i)">
            <summary>Create a list of all the laws at the given position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Laws.LawUtil.CountActiveLawsAtPosition(Eco.Shared.Math.Vector2i)">
            <summary>Counts the active laws of all settlements at this position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GamePickerList.DescribeEntries(Eco.Shared.Localization.LocString)">
            <summary> Returns a hoverable link with entries inside. </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GameValueType">
            <summary> Contains data about a given GameValue type, for the client to use when building its list.  </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.GameValueTypeContext">
            <summary> Class for a contextually specified type. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.GameValueUtils.TryLoc(Eco.Gameplay.Civics.GameValues.GameValue{System.Boolean},System.FormattableString,Eco.Core.Utils.PropertyScanning.IContextObject,Eco.Gameplay.Players.User)">
            <summary>
            Does the test for a GameValue, notifies in a failure, and returns true or false for "should we continue"
            </summary>
            <param name="reqs"></param>
            <param name="failureDesc"></param>
            <param name="context"></param>
            <param name="notify"></param>
            <returns></returns>
        </member>
        <member name="T:Eco.Gameplay.Civics.GameValues.NamedVariable">
            <summary> A form that allows users to give a name to specified float game value.
            These names are bieng replaced with their definition during evaluation process of the formula defined in parent <see cref="T:Eco.Gameplay.Civics.GameValues.TextFormula" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.TextFormula.GenerateDescription">
            <summary>Generates description by <see cref="P:Eco.Gameplay.Civics.GameValues.TextFormula.Formula" />. Replaces Name and Definition variables with links.</summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.PropertyRequirements.MakeOwnedResult(Eco.Core.Utils.Eval{Eco.Gameplay.Aliases.IAlias},Eco.Gameplay.Property.PropertyPlot,System.Boolean)">
            <summary> Checks if <paramref name="plot" /> owned by <paramref name="alias" /> and compares result with <paramref name="testOwned" />. Returns <see cref="T:Eco.Core.Utils.Eval`1" /> for the test. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.PropertyRequirements.MakeAuthorizedResult(Eco.Core.Utils.Eval{Eco.Gameplay.Aliases.IAlias},Eco.Gameplay.Property.PropertyPlot,System.Boolean)">
            <summary> Checks if <paramref name="plot" /> authorized for <paramref name="alias" /> and compares result with <paramref name="testAuthed" />. Returns <see cref="T:Eco.Core.Utils.Eval`1" /> for the test. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.GameValues.Values.PropertyRequirements.MakeResidentResult(Eco.Core.Utils.Eval{Eco.Gameplay.Aliases.IAlias},Eco.Gameplay.Property.PropertyPlot,System.Boolean)">
            <summary> Checks if <paramref name="plot" /> is the residence for <paramref name="alias" /> and compares result with <paramref name="testAuthed" />. Returns <see cref="T:Eco.Core.Utils.Eval`1" /> for the test. </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.MoneyTransfer_LegalAction.TransferInfo">
            <summary> <see cref="M:Eco.Gameplay.Civics.MoneyTransfer_LegalAction.GetAndCheckValues(Eco.Core.Utils.PropertyScanning.IContextObject)" /> converts and checks game values using provided context and fills this container with the data. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.MoneyTransfer_LegalAction.ComposeDefaultData(Eco.Gameplay.Civics.MoneyTransfer_LegalAction.TransferInfo,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,System.Boolean,Eco.Gameplay.Players.User)">
            <summary> Creates an instance of <see cref="T:Eco.Gameplay.Economy.TransferData" /> and fills it with default values based on the provided params. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.MoneyTransfer_LegalAction.DescribeAmount(System.Nullable{System.Single},System.String)">
            <summary> Uses provided value to compose a message in a format "X currency name (description of X)" or some variants if something is not provided or the game value is a constant. </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Misc.CivicsTooltip">
            <summary>
            Tooltip handler for Civics tooltips.
            <para> TypeTooltip hands over the tooltip generation logic to this class for type properties that are being hovered. </para>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsTooltip.GetOrAddCachedTooltip(System.Type)">
            <summary> Tries to get the tooltip text for a specific type from cache -- if it isn't cached, generates, caches, then returns it. <para> Cached tooltips are localized. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsTooltip.MakeTwoPartsTable(System.Type,System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Collections.Generic.List{Eco.Shared.Localization.LocString},System.Collections.Generic.List{Eco.Shared.Localization.LocString})">
            <summary> A table with two parts for the type. One with members that match the func, and another with the ones that don't. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsTooltip.FormTable(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.PropertyInfo},System.Collections.Generic.List{Eco.Shared.Localization.LocString})">
            <summary> Forms and returns a table that is ready to be used by Client's UI after passing through 'Text.Table'. <para> Consists of a header, followed by a row for each property. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.CivicsUtils.GetHostedProposables(System.Collections.Generic.IEnumerable{System.Type},Eco.Gameplay.Objects.WorldObject)">
            <summary> Returns objects that are currently hosted on this world object. </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.DisplayErrorUIExtension.CheckAndUpdateValidity(Eco.Gameplay.Civics.Misc.IDisplayErrorUI,System.Reflection.PropertyInfo,System.Object)">
            <summary>
            This function will check and update IDisplayErrorUI.Errors property.
            </summary>
            <param name="displayErrorUI"></param>
            <param name="prop"></param>
            <param name="objParent"></param>
        </member>
        <member name="M:Eco.Gameplay.Civics.Misc.ProposableUtils.HasValidConstitution(Eco.Gameplay.Civics.Misc.IProposable)">
            <summary>Checks if the settlement associated with this proposable is active and valid.</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Objects.CivicObject">
            <summary>
            An object that can have civic slots and/or civic actions.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Titles.AppointedTitle">
            <summary>
            A title that can be assigned managers and users.
            This is different from an <see cref="T:Eco.Gameplay.Civics.Titles.ElectedTitle" /> in that it can be created and set by anyone at a Registrar object, whereas <see cref="T:Eco.Gameplay.Civics.Titles.ElectedTitle" /> can only be set via elections.
            Functionally, they both serve the same purpose: defining a set of users represented by a title.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Civics.Titles.ElectedTitle.GetLatestOfficeHolders">
            <summary>Get list of current or latest holders of this office, if there is none we get an empty list</summary>
        </member>
        <member name="T:Eco.Gameplay.Civics.Titles.IHasBackupOwner">
            <summary> When an element with this interface is removed, all of its property goes to this deputy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.AirPollutionComponent.ApplyLawAndGetResult">
            <summary> Checks if the Law allows Air Pollution. If it doesn't, turns off component. Returns result with message. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.AirPollutionComponent.TryGetPollutionPosition(Eco.Shared.Math.Vector3i@)">
            <summary>Returns position where air pollution will be produced by the component.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.AuthDataTrackerComponent">
            <summary> Tracks object's consumers list and saves it into persistent data. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.Auth.IAuthChangeListenerComponent">
            <summary>
            Interface to be used with <see cref="T:Eco.Gameplay.Objects.WorldObjectComponent" />s.  If present, the component
            will get events from the parent <see cref="T:Eco.Gameplay.Objects.WorldObject" /> about auth ownership changes.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ChunkSubscriberComponent.UpdateSubscriptions(Eco.Gameplay.Components.IChunkSubscriber)">
            <summary> Update the chunk subscriptions for this subscriber. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ChunkSubscriberComponent.UpdateSubscriptionsWithChunks(Eco.Gameplay.Components.IChunkSubscriber,System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i})">
            <summary> Update the subscriptions for this subscriber to specific chunks. (Note: Removes previous subscriptions.) </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ChunkSubscriberComponent.UnSubscribe(Eco.Gameplay.Components.IChunkSubscriber)">
            <summary> Unsubscribes the given subscriber from all chunks. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.GetConnectedInventories(Eco.Gameplay.Players.User,System.Boolean,System.Boolean)">
            <summary>
            gets all valid inventories we can take/put items
            </summary>
            <param name="user"></param>
            <param name="input">require take ability from inventories</param>
            <param name="output">require put ability from inventories</param>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.UpdateTotalCraftingTimer(System.Object)">
            <summary>When <see cref="P:Eco.Gameplay.Components.CraftingComponent.BottleNecked" /> value has changed. We have to update the state of the crafting timer. Start counting the time if it isn't bottle necked. Otherwise stop the counting.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingComponent.MakeOrderNotification(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Make short message only with few work orders, detailed information is not necessary here.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.CraftingFees">
            <summary>
            This class allows to calculate, pay and store escrowed payments withing craft/repair.
            Tables which has CreditComponent could set fee for using that table. This class will operate with payments allowing to retrieve back paid money for canceled work orders.
            Stores fee data on the moment work order was created. So further changes to fee/currency would not affect stored payment.
            When payment is requested, money are transfered to Escrow account saving all needed transfer info within serialized fields.
            When using escrow account is not needed (repair or craft single item) transfer is performed instantly.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayRepairFees(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Items.Item)">
            <summary>Pay repair fees instantly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayCraftingFees(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject,System.Single,System.Int32,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Items.WorkOrder)">
            <summary> Try to pay crafting fees for work order. If multiple orders queued payment transfered to escrow account and owner will receive payment per finished order. On work order cancel tries to refund. Otherwise returns null.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayCraftingFee">
            <summary>Pay stored crafting fee per 1 unit. If table becomes public or free - refund all stored money.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.RefundCraftingFee">
            <summary>Refund remaining fees if any left in escrow bank account.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.CreditDataChanged">
            <summary>When CreditData changed checks if we are still have to pay. If not - refund all stored money.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CraftingFees.PayFees(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Objects.WorldObject,System.Single,System.Int32,Eco.Gameplay.Economy.BankAccount,Eco.Shared.Localization.LocString)">
            <summary>Pay fees instantly, transfer data not stored</summary>
        </member>
        <member name="F:Eco.Gameplay.Components.CreditItemData.SelectedBankAccountBalanceChangedEvent">
            <summary>Raised when balance for <see cref="P:Eco.Gameplay.Components.CreditItemData.Currency" /> changes in <see cref="P:Eco.Gameplay.Components.CreditItemData.BankAccount" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Components.CreditItemData.OnBankAccountValidityChanged(System.Boolean)">
            <summary> Listener for when validity of bank account gets changed, this basically removes it and sets the bank account as null. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ElevatorComponent.ReceiveUpdate(Eco.Shared.Serialization.BSONObject)">
            <summary>Update cage's position, velocity and state.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.FuelSupplyComponent.CanConsumeFuel(System.Single)">
            <summary> Checks whether it's possible for the component to burn provided amount of energy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.FuelSupplyComponent.ConsumeAsMuchAsPossible(System.Single)">
            <summary>Consumes as much <paramref name="joules" /> as possible and returns actually consumed joules. It tries to load fuel from inventory when Energy fully consumed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.LinkComponent">
            <summary> This component manages connections to other world objects within a given radius </summary>
            <remarks> This assumes the world object is stationary </remarks> 
            <inheritdoc />
        </member>
        <member name="P:Eco.Gameplay.Components.LinkComponent.BaseConnectionRadius">
            <summary>Radius measurement used to connect to other objects as defined in the object's definition.</summary>
        </member>
        <member name="P:Eco.Gameplay.Components.LinkComponent.ObjectConnectionRadius">
            <summary>Radius measurement used to connect to other objects with applied modifiers. Based on the <see cref="P:Eco.Gameplay.Components.LinkComponent.BaseConnectionRadius" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.LinkComponent.LinkSettingsAlias(Eco.Gameplay.Aliases.IAlias)">
            <summary> This alias will be used to get settings instead of provided one.
            For demo see how shared link component overrides this value and returns parent's owner. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.LinkComponent.GetSortedLinkedComponents(Eco.Gameplay.Aliases.IAlias,System.Boolean,System.Boolean)">
            <summary>
            Get Sorted linked storages which are able to take/put items </summary>
            <param name="alias"></param>
            <param name="source">is able to take items</param>
            <param name="target">is able to put items</param>
            <returns>list of storages</returns>
        </member>
        <member name="M:Eco.Gameplay.Components.LinkComponent.NewDefaultLinkSettings(Eco.Gameplay.Aliases.IAlias,Eco.Gameplay.Objects.WorldObject,System.Type)">
            <summary>
            Gets <see cref="T:Eco.Gameplay.Components.LinkComponent.LinkSettings" /> which <see langword="this" /> should use when linking to <see cref="T:Eco.Gameplay.Components.StorageComponent" /> of type <paramref name="compType" />
            attached to <paramref name="linkedObj" />
            </summary>
            <param name="alias"></param>
            <param name="linkedObj"><see cref="T:Eco.Gameplay.Objects.WorldObject" /> that <see langword="this" /> wants to link to</param>
            <param name="compType"><see cref="T:System.Type" /> of <see cref="T:Eco.Gameplay.Components.StorageComponent" /> attached to <paramref name="linkedObj" /> for which <see cref="T:Eco.Gameplay.Components.LinkComponent.LinkSettings" /> will be returned</param>
        </member>
        <member name="M:Eco.Gameplay.Components.MinimapComponent.OnOwnerChanged">
            <summary>Send update to client when object's owner has changed</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.Dismount(Eco.Gameplay.Players.Player)">
            <summary> Dismounts specific <paramref name="player" /> from all occupied seats. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.DismountSeat(System.Int32)">
            <summary> Dismounts player at specific <paramref name="seatIndex" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.MountComponent.DismountDestroyedPlayers">
            <summary> Dismounts all disconnected players. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.NameDataTrackerComponent">
            <summary> Tracks object's name changes and saves it into persistent data. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.OnOffComponent.IOnOffMessagesContainer">
            <summary> Components with this interface can proide themselves via <see cref="M:Eco.Gameplay.Components.OnOffComponent.Setup(System.Func{Eco.Gameplay.Players.User,System.Boolean,Eco.Core.Utils.Result},Eco.Shared.Items.AccessType,Eco.Gameplay.Components.OnOffComponent.IOnOffMessagesContainer)" />
            to override default messages. See <see cref="T:Eco.Gameplay.Components.StoreComponent" /> for a demo. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.OnOffComponent.Setup(System.Func{Eco.Gameplay.Players.User,System.Boolean,Eco.Core.Utils.Result},Eco.Shared.Items.AccessType,Eco.Gameplay.Components.OnOffComponent.IOnOffMessagesContainer)">
            <summary> Overrides default behaviour of the component. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.OnOffComponent.SetOnOff(Eco.Gameplay.Players.User,System.Boolean)">
            <summary> Check user's auth and tries to set the on-off state of the component.
            Can contain additional checks and feedbacks. See how <see cref="T:Eco.Gameplay.Components.StoreComponent" />
            changes behaviour of this component. Null user bypasses auth check.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.PluginModulesComponent">
            <summary> Component which allows to add Plugin Modules to a world object (like better efficiency, longer labor queue etc). </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.PluginModulesComponent.AllowedModulesInfo">
            <summary> Cached information about allowed modules (tags) you can plug. Actual module items stored in inventory. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.PowerGeneratorComponent.UpdateJoulesPerSecond(System.Single)">
            <summary> Updates the output of this Power Generator and alters the Power Grid Component to reflect the change. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.PowerGrid.LateTick">
            <summary>
            Postpone all calculations until PowerGrid become stable, we don't want to make billion calculations on every change, especially on initialize stage.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.SharedLinkComponent">
            <summary> This link component uses parent owner's shared link settings if provided alias has full access to the property. 
            In other words, users with full access can change linked objects and expect that other owners will also receive these changes.
            Currently used for stores. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SharedLinkComponent.HasFullAccess(Eco.Gameplay.Aliases.IAlias)">
            <summary> Checks whether this alias has full access to the property. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SharedLinkComponent.LinkSettingsAlias(Eco.Gameplay.Aliases.IAlias)">
            <summary> Overrides provided alias if it has full access (replaces it with parent owner). </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.SolarGeneratorComponent">
            <summary> A component that will adjust the power output of an object that requires a view of the sun. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.SetSkyCoordinates">
            <summary> Calculates a horizontal plane of coordinates that this generator cares about being clear of obstruction for the purpose of a clear view of the sky. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.ChunksChanged">
            <summary> Trigger the associated behavior if the chunks in RelevantChunkPositions are changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.UpdateChunkSubscriptions">
            <summary> Checks if there are any new chunks in the columns this generator occupies and subscribes to them. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.SolarGeneratorComponent.SkyTest">
            <summary>
            Adjusts power output based on this generators view of the sky.
            Calculated by selecting each block occupied in a horizontal footprint and checking if it is the top block or not.
            OutputPower = InitializedPower * PercentUncovered
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.StatusElement.Priority">
            <summary> Status component uses this value to order entries. The lower the value, the sooner this element appears in the list. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WorldStockpileComponent">
            <summary>
            This stockpile syncs changes with blocks in the world when they change.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WorldStockpileComponent.SyncBlocksToWorld">
            <summary> Updates blocks spawned by stockpile to match stockpile's inventory </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.ModularStockpileComponent">
            <summary>
            This component packages up the blocks of a stockpile into a format that can be used by moving objects, such as vehicles.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.StockpileCrateBlock">
            <summary>
            A generic block for items that aren't block items. Represented as a crate.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StockpileComponent.TickOnDemand">
            <inheritdoc cref="M:Eco.Gameplay.Objects.ITickOnDemand.TickOnDemand" />
        </member>
        <member name="M:Eco.Gameplay.Components.StockpileComponent.UpdateStockpileFromInventory">
            <summary> Updates contents of <see cref="P:Eco.Gameplay.Components.StockpileComponent.BlockTypes" /> to match contents of <see cref="F:Eco.Gameplay.Components.StockpileComponent.storage" /> </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.StockpileStackRestriction.SurpassStackSize">
            <inheritdoc cref="P:Eco.Gameplay.Items.InventoryRestriction.SurpassStackSize" />
        </member>
        <member name="M:Eco.Gameplay.Components.StorageComponent.GetItemsUserCanTake(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Item,System.Boolean,System.Func{Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.Item,System.Boolean})">
            <summary>Get items available to user in this inventory</summary>
            <param name="restrictionsPassed">possible restrictions of other inventories</param>
        </member>
        <member name="T:Eco.Gameplay.Components.StoreCategory">
            <summary> Subgroup of offers at the store. Each group will be showed and handled separated by UI, allowing users to group similar elements as they want.  </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StoreCategory.SetTrades(System.Collections.Generic.List{System.Int32})">
            <summary> It updates offers list to match item ids, creating or deleting offers as necesary. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StoreCategory.GetBestName(System.Collections.Generic.List{System.Int32})">
            <summary> Choose the best title for the category based on the item tags in itemIDs. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StoreComponent.CreateCategoryWithOffers(System.Collections.Generic.List{System.Int32},System.Boolean)">
            <summary>
            Creates new category and tries to pick best name based on tags
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StoreComponent.BuildTransfers(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Components.StoreComponent.PurchaseData,Eco.Gameplay.Players.User,Eco.Gameplay.Economy.BankAccount)">
            <summary> Adds related transfers to the pack. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.StoreComponent.PurchaseData.TradeDesc(System.Boolean)">
            <param name="describeToTradeInit">Will you describe the trade to the player who initialized the trade?</param>
        </member>
        <member name="T:Eco.Gameplay.Components.StoreItemData">
            <summary> This class contains stores data: all offers and currency. It handles callbacks for offer changes.  </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.TradeOffer">
            <summary> Represents an offer of the store. Contains description of condition of sell/buy, the price, the kind of item. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.TailingsReportComponent">
            <summary> Component responsible for reporting any ground pollution producing items in the world object storage. </summary>
        </member>
        <member name="F:Eco.Gameplay.Components.TailingsReportComponent.TailingsInfo">
            <summary> Static collection which contains information about all ground pollution producing items. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.TailingsReportComponent.UpdateTailings">
            <summary> Checks storage for items producing ground pollution and updates the info in the TailingsCache/&gt;. </summary>
        </member>
        <member name="P:Eco.Gameplay.Components.VehicleComponent.OutOfFuel">
            <summary> This property set if Vehicle has fuel supply and it is out of energy. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.VehicleComponent.TrySetSinking(Eco.Shared.Math.Vector3i)">
            <summary>This RPC is for setting vehicle is underwater or not using given position. Do nothing if vehicle is able to move underwater. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.VehicleComponent.CheckFuel">
            <summary> Updates fuel status for the vehicle (if <see cref="F:Eco.Gameplay.Components.VehicleComponent.fuelSupply" /> available). </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WardrobeComponent">
            <summary> Component that adds wardrobe in a storage panel, allows ability to swap clothing using interaction </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WaterRiverGeneratorComponent">
            <summary> A component that will adjust the power output of an object that requires river water. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.ChunksChanged">
            <summary> Trigger the associated behavior if the chunks in RelevantChunkPositions are changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.WaterTest">
            <summary>
            Tests if the Waterwheel meets all necessary conditions to function.
            The Waterwheel needs at least some of its blocks submerged in water to function, and needs to be free of obstructions.
            In order for water to fill blocks occupied by the waterwheel, some of the blocks have to be set as EmptyBlock, which opens the possibility of a block being placed there, so checks exist to ensure this has not happened.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.CheckPositions(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Vector3i,System.Int32@,System.Boolean@,Eco.Shared.Localization.LocString@)">
            <summary> Checks the given positions for water or obstructions. </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="water"> How many positions are IWaterBlocks. </param>
            <param name="obstructed"> True if one of the blocks is NOT water or empty. </param>
            <param name="killReason"> The reason, if any, this position is invalid. Including the world-position of the offending block. </param>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.KillPower(Eco.Shared.Localization.LocString)">
            <summary> Sets the power to zero and updates the status message. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.InFreshwaterEnable">
            <summary> Determines if the generator is in Freshwater, if not it shuts down the generator. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WaterRiverGeneratorComponent.FreshWaterCheck(Eco.Shared.Math.Vector2i)">
            <summary> Returns true if the position provided is in Freshwater (of 50% or less saltwater). </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.WindGeneratorComponent">
            <summary> A component that will adjust the power output of an object that requires a clear area for wind. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.ChunksChanged">
            <summary> Trigger the associated behavior if the chunks in RelevantChunkPositions are changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.UpdateChunkSubscriptions">
            <summary> Checks if there are any new chunks in the columns this generator occupies and subscribes to them. </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.SetCoordinates">
            <summary> Calculates and stores the plane of coordinates to use in the WindCheck and RelevantChunkPositions(). </summary>
        </member>
        <member name="M:Eco.Gameplay.Components.WindGeneratorComponent.WindTest">
            <summary> Adjusts power output based on this generators view of the sky. </summary>
        </member>
        <member name="T:Eco.Gameplay.Components.ClaimsComponent">
            <summary>Component that spawns claim stakes and claim papers based on the size of a settlement. These can then be distributed to citizens to allow them to claim more land from their claim stakes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ClaimsComponent.UpdateStakesAndClaimsIfCrisis(Eco.Gameplay.Players.User)">
            <summary>Callback for when the claims inventory changes. If there's a property crisis for our settlement, it might need to despawn new stakes or claims added here, so watch it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ClaimsComponent.AdjustSpawnedStakesAndClaims(System.Type,System.Int32)">
            <summary>Callback we register with the settlement to create or remove claims from our inventory.  The settlement determines this based on number of citizens. 
            Returns the number of things spawned/removed.  Count can be positive (spawn) or negative (despawn).  It returns similarly: positive for spawned count,
            negative for despawned.</summary>
        </member>
        <member name="T:Eco.Gameplay.Components.ClaimStakeComponent">
            <summary> Allows claiming connected plots to where the parent is placed. Adding claim papers will charge 
            it up. The surveyor tool lets you make the claims.</summary>
        </member>
        <member name="M:Eco.Gameplay.Components.ClaimStakeComponent.DescribePlotsClaimed">
            <summary>Describe the plots that are claimed and where theyre coming from. For a foldout in the description.</summary>
        </member>
        <member name="F:Eco.Gameplay.Disasters.DisasterPlugin.StockpileDetectionDistance">
            <summary> Crater size + this value is a minimum distance from crater center for a stockpile to update its inventory after meteor impact </summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.IDynamicValueContext">
            <summary>
            <p>Context for evaluating Dynamic Values (passes as parameter to <see cref="M:Eco.Gameplay.DynamicValues.IDynamicValue.GetCurrentValue(Eco.Gameplay.DynamicValues.IDynamicValueContext)" />.</p>
            <p>It provides a way to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> in different contexts.</p>
            <p>In example <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> may be evaluated for <see cref="T:Eco.Gameplay.Players.User" /> - in this case you should create <see cref="T:Eco.Gameplay.DynamicValues.UserDynamicValueContext" />.</p>
            <p>Alternatively you may need to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> for crafting table <see cref="T:Eco.Gameplay.Modules.PluginModule" /> - in this case you should create <see cref="T:Eco.Gameplay.DynamicValues.ModuleContext" />.</p>
            <p>Depending on context <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" /> may be evaluated in different ways. In example for <see cref="T:Eco.Gameplay.DynamicValues.UserDynamicValueContext" /> <see cref="P:Eco.Gameplay.DynamicValues.IDynamicValueContext.Position" /> will be retrieved from <see cref="T:Eco.Gameplay.Players.User" />,
            but for <see cref="T:Eco.Gameplay.DynamicValues.ModuleContext" /> it will use a crafting table position. Some values, like <see cref="T:Eco.Gameplay.DynamicValues.ModuleModifiedValue" />, may only be evaluated for specific context, otherwise they will return base value.
            I.e. if you view Recipe from Ecopedia it will show unmodified ingredient amount and crafting time, but on crafting table it will show values modified by modules.</p>
            </summary>
        </member>
        <member name="P:Eco.Gameplay.DynamicValues.IDynamicValueContext.User">
            <summary> User for which value should be evaluated (i.e. for <see cref="T:Eco.Gameplay.DynamicValues.TalentModifiedValue" />). </summary>
        </member>
        <member name="P:Eco.Gameplay.DynamicValues.IDynamicValueContext.Position">
            <summary> Position where value should be evaluated (i.e. for <see cref="T:Eco.Gameplay.DynamicValues.LayerModifiedValue" />). </summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.ModuleContext">
            <summary> Dynamic Value Context for Module (like resource efficiency or speed efficiency). Can be used to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.ModuleModifiedValue">
            <summary> Dynamic value modified by Module. It retrieves the module from context and modifies value using the module. </summary>
        </member>
        <member name="M:Eco.Gameplay.DynamicValues.ModuleModifiedValue.#ctor(System.Single,System.Type,Eco.Gameplay.DynamicValues.DynamicValueType)">
            <summary>
            Initializes a new instance of the <see cref="T:Eco.Gameplay.DynamicValues.ModuleModifiedValue" /> class.
            </summary>
            <param name="baseValue">Base unmodified value.</param>
            <param name="skillType">Skill associated with the value.</param>
            <param name="valueType">Type of value (Efficiency, Speed etc).</param>
        </member>
        <member name="F:Eco.Gameplay.DynamicValues.SkillModifiedValueManager.objectBenefits">
            <summary>object type to smvs that pertain to it.  Generally these are items, but can also be objects such as trees</summary>
        </member>
        <member name="F:Eco.Gameplay.DynamicValues.SkillModifiedValueManager.skillBenefits">
            <summary>Maps a skill type to smvs</summary>
        </member>
        <member name="M:Eco.Gameplay.DynamicValues.SkillModifiedValueManager.GetBenefitNameForType(System.Type)">
            <summary>Get UILink based on type using runtime type ids</summary>
        </member>
        <member name="T:Eco.Gameplay.DynamicValues.UserDynamicValueContext">
            <summary> Dynamic Value Context for User (like labor efficiency or yield increase). Can be used to calculate <see cref="T:Eco.Gameplay.DynamicValues.IDynamicValue" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Common.WorkableExtensions.MoveWorkables(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.Common.Workable},Eco.Gameplay.Economy.ContainedWorkables,Eco.Gameplay.Objects.WorldObject,System.Int32)">
            <summary> Removes workables from their host containers and adds them to the provided one. Amount of entries to move can be capped. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.ContractBoardComponent.TryGetFromStash(Eco.Gameplay.Players.Player,System.Boolean,System.Boolean)">
            <summary> Checks if there are stashed entries and suggests to post them on this board. </summary>
            <returns> False if there are no stashed entries or if the player declined the suggestion. </returns>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.CurrencyInfo">
            <summary> Holds the necessary currency info for contract clauses related with currency transfers. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.IClauseList">
            <summary> Implement on classes that can host Clauses (e.g.: 'Contract' and 'ContractClauseNested'). </summary>
            <remarks> Used to get all hosted clauses from the parent level (e.g.: Contract will check its clauses and clauses that are children of ContractClauseNested at any level). </remarks>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.ClauseListExtensions.ClausesRecursive(Eco.Gameplay.Economy.Contracts.IClauseList)">
            <summary>Gets simple version of contract clause description in the format: X Contract Clauses</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Contracts.Contract.RelevantUsers">
            <summary> Returns all the users that are involved in this contract -- the client and the contractor, if they're not null. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.ContractClause">
            <summary> Base class for any contract clause that a contract can contain. </summary>
            <remarks> Contract clauses are part of a contract and need to be completed in order to claim the rewards -- which is also a contract clause. </remarks>
        </member>
        <member name="T:Eco.Gameplay.Economy.Contracts.ContractClauseNested">
            <summary> Contract clause that can host other contract clauses. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.CurrencyAndAmountGameValues.DoTransferLoc(System.FormattableString,Eco.Gameplay.Players.User,Eco.Core.Utils.PropertyScanning.IContextObject,Eco.Gameplay.Economy.BankAccount,Eco.Shared.Items.TransferType)">
            <summary> Try to pay the fee in the given currency, querying for the bank account source. Handles all errors and notifications.</summary>
            <param name="propName">Name of the property as you want it displayed in the notifications, ie 'tuition fee'. It will be localized.</param>
            <param name="user">The user making the payment.</param>
            <param name="context">Context with which we query these params.</param>
            <param name="targetAccount">Account that its paid into.</param>
            <param name="type">The kind of transfer it classifies as.</param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.DualPermissions.VerifyCanSet(Eco.Gameplay.Players.Player,Eco.Core.Utils.IClientControlledContainer,System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Verify if the player and the new set can be set to the container. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.INullCurrencyAllowed">
            <summary> Credit component will hide null-crrency option on the client side
            if parent world object does not implement this interface. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.DescribeWealth(Eco.Gameplay.Players.User)">
            <summary> Returns a string with user's percent ownership of this account. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccount.DescribeHoldings">
            <summary> Returns an entitled text block with this account's holdings. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.BankAccountManager.DirectTransfer(Eco.Gameplay.Players.User,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.Currency,System.Single)">
            <summary> Public acessor for game action tests. Use <see cref="M:Eco.Gameplay.Economy.Transfers.Transfer(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Economy.TransferData)" /> instead. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.PersonalBankAccount">
            <summary> Player's default bank account with an infinite amount of their personal currency. The player cannot be removed from managers list. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.GovernmentBankAccount">
            <summary> Accounts of this type can be targeted by Tax/Pay legal actions. Wealth calculations for users do not include these accounts. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.TreasuryBankAccount">
            <summary> This special account will be used as a default government account. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.ContractEscrowBankAccount">
            <summary> This special account will be used to temporary store payments for work parties and contracts. </summary>
        </member>
        <member name="F:Eco.Gameplay.Economy.Reputation.ReputationRelationshipChangedEvent">
            <summary>
            Raised when relationship between two users changes.
            <see cref="T:Eco.Gameplay.Economy.Reputation" /> passed to handler is <see cref="T:Eco.Gameplay.Economy.Reputation" /> of user who adjusted their relationship
            with user whose <see cref="P:Eco.Gameplay.Players.Player.DisplayName" /> is passed in second parameter.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Transfers.AccountsChangeSet">
            <summary> A class used by transfers to track requested changes for account holdings. 
            This allows to perform several transfers within a single pack and check their final result without caring what was happening (and in which order) inbetween.
            Every change set is bound to not-yet-disposed game action pack. </summary>
        </member>
        <member name="T:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.AccountChange">
            <summary> A container for requested changes. </summary>
        </member>
        <member name="F:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.changes">
            <summary> Requested changes are stored here. </summary>
        </member>
        <member name="P:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.Applied">
            <summary> Already applied change sets should be distinguishable from others. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.AddChange(Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.Currency,System.Single,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Eco.Shared.Services.NotificationCategory},Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString})">
            <summary> Tries to add new change request. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.Apply">
            <summary> Performs the changes without any checks.
            Should stay private and be triggered as a post effect of the related pack. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.Verify">
            <summary> Ensures that this change set will not result negative holdings. </summary> // TODO: Pre-test for already existing negative holdings?
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.NotifyAll">
            <summary> Groups transfers by their descriptions and tags. Then sends messages to according channels. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.NotifyAccountHolders(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.Transfers.AccountsChangeSet.AccountChange})">
            <summary>Sends Transfer Notification to all Bank account Holders</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.Totals(Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.Currency)">
            <summary> Returns total change for the account. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.AccountsChangeSet.TotalsForCurrency(Eco.Gameplay.Economy.Currency)">
            <summary> Returns a collection of accounts and their total deltas for the currency. </summary>
        </member>
        <member name="F:Eco.Gameplay.Economy.Transfers.AlmostZero">
            <summary> Values within this cap will be considered as zero. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.Transfer(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Economy.TransferData)">
            <summary> Uses provided <see cref="T:Eco.Gameplay.Economy.TransferData" /> to change holdings in pack's post effect.
            Some demo cases with different logic: <list type="bullet">
            <item> Store component triggers taxes for whole buy/sell amounts, but transfers only their difference: <see cref="M:Eco.Gameplay.Components.StoreComponent.BuildTransfers(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Components.StoreComponent.PurchaseData,Eco.Gameplay.Players.User,Eco.Gameplay.Economy.BankAccount)" />. </item>
            <item> Tax legal action requests a custom value to be paid from users and suppresses game actions to prevent law infinite loops (like "if tax then tax"): <see cref="M:Eco.Gameplay.Civics.Tax_LegalAction.ComposeTransfers(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Civics.MoneyTransfer_LegalAction.TransferInfo)" />. </item>
            <item> Treasury component implements similar taxation logic, but it is focused on accounts instead of users and does trigger game actions. This component is currently the only one who triggers ReceiveGovernmentFunds</item>
            <item> Work party's payment triggers transfer from escrow to laborer's account, but in terms of users it's from creator to laborer, so it ignores auth by granting super access: <see cref="M:Eco.Gameplay.Economy.WorkParties.CurrencyPayment.PayUser(Eco.Gameplay.Economy.WorkParties.Laborer,System.Single)" />. </item>
            </list><returns> Returns transferred amount. </returns></summary> // Return value is not currently used. And it's hard to make it precise untill the pack fully resolves.
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TransferNow(Eco.Gameplay.Economy.TransferData,System.Boolean)">
            <summary> A shortcut that performs a transfer using internally created pack and returns the result. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.Verify(Eco.Gameplay.GameActions.GameActionPack)">
            <summary> Checks provided pack's early result and its related accounts change set. 
            Failed test for the change set means that transfers cannot be performed (will result negative holdings). </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TransferInternal(Eco.Gameplay.GameActions.GameActionPack,System.Single,Eco.Gameplay.Economy.Currency,Eco.Gameplay.Economy.BankAccount,Eco.Gameplay.Economy.BankAccount,System.Boolean,System.Boolean,System.Boolean,System.Nullable{Eco.Shared.Services.NotificationCategory},Eco.Shared.Localization.LocString,System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString},System.Nullable{Eco.Shared.Localization.LocString})">
            <summary> Gets or creates change set for the pack, adds related deltas and composes post-effect. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TryDistributeTax(System.Collections.Generic.IEnumerable{Eco.Gameplay.Economy.BankAccount},Eco.Gameplay.Economy.Currency,System.Single,Eco.Gameplay.Economy.Transfers.ValueSpreadType,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},Eco.Gameplay.Economy.Transfers.AccountsChangeSet)">
            <summary> Calculates how much should be spent from each of the provided accounts.
            Depending on distributeEvenly, calls either <see cref="M:Eco.Gameplay.Economy.Transfers.TryDistributeTaxEvenly(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})" /> or <see cref="M:Eco.Gameplay.Economy.Transfers.TryDistributeTaxСonsistently(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})" />. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TryDistributeTaxСonsistently(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Tries to pay as much as possible from provided accounts one by one:
            if some account is unable to pay the whole value, the remainder will be paid from the next one,
            i.e. three accounts with holdings 10, 100, 1000 will pay 10, 50, 0 respectively if requested value is 60.
            If order matters, provide already sorted collection of accounts. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TryDistributeTaxEvenly(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Recursively splits provided amount into equal parts and tries get this value from the accounts that still can pay:
            if some account is unable to pay that equal part, the remainder will be spread between thouse that still can;
            i.e. three accounts with holdings 10, 100, 1000 will pay 10, 25, 25 respectively if requested value is 60. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TrySpreadEvenly(System.Single,System.Collections.Generic.List{Eco.Gameplay.Economy.BankAccount},System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Private recursive helper that implements logic of <see cref="M:Eco.Gameplay.Economy.Transfers.TryDistributeTaxEvenly(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.Transfers.TryRepeatTax(System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single},System.Single,System.Collections.Generic.Dictionary{Eco.Gameplay.Economy.BankAccount,System.Single})">
            <summary> Tries to pay target value from each provided account. </summary>
            <returns> Distribution of value that can be paid from the accounts and amount that is not possible to pay from the accounts. </returns>
        </member>
        <member name="T:Eco.Gameplay.Economy.TransferData">
            <summary> A struct to customize behaviour of <see cref="M:Eco.Gameplay.Economy.Transfers.Transfer(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Economy.TransferData)" /> (see its summary for demo cases). </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.MakeLaborNotification(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Builds final add labor notification collecting all labor data while timer is on, so do not spam with notifications </summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.MakeAddItemsNotification(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Builds final notification with counting all items added while timer is working. By each user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Economy.WorkParties.WorkParty.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)">
            <summary> Handles aggregate payments for PayAsYouGo feature, User is the laborer reference and weighted percent delta is the change in his contribution to the work party. </summary>
            <inheritdoc cref="M:Eco.Gameplay.Civics.Economy.IHasUserAggregatedAmount.OnUserAggregateAmountDue(Eco.Gameplay.Players.User,System.Single)" />
        </member>
        <member name="T:Eco.Gameplay.GameActions.ActionUtil">
            <summary>
            Utility class to help with keeping track of IGameActionAware listeners, and notifying them when actions are performed.
            <para> Used by systems like Contracts, WorkParties, Item Distributions, etc., to keep track of progress. </para>
            </summary> 
        </member>
        <member name="F:Eco.Gameplay.GameActions.ActionUtil.Listeners">
            <summary>
            Holds listeners that want to be notified whenever a GameAction is being performed.
            <para> Also used by AuthManager to check if auth should be overriden for a specific action because it's allowed by one (e.g. a Contract that allows usage of someone's Oven). </para>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.ActionUtil.ActionPerformed(Eco.Gameplay.GameActions.GameAction)">
            <summary> Notifies all listeners that an action was performed. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.AtomicActions">
            <summary>
            Atomic actions are anything that has must be performed in a single transaction.
            Performing an atomic action builds up the ActionPack, which consists of a set of things to test at first, game actions to run
            through laws and contracts, and then post-effects that are run if everything in the action pack succeeds, and finally things that
            are disposed when the pack is finished.
            All atomic actions should check the early-out failure on the pack before doing anything
            (not necessary for actions that utilize <see cref="M:Eco.Gameplay.GameActions.AtomicActions.PerformMultiblockToolAction(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Func{Eco.Shared.Math.WrappedWorldPosition3i,Eco.Core.Utils.Result})" /> since the check will be performed there).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DropRubble(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Items.BlockItem,Eco.Gameplay.Items.Inventory,Eco.Shared.Math.Vector3,System.Single)">
            <summary> Tries to remove block item from the inventory to spawn it as a loose rubble. Burns player's calories if needed. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.BurnCalories(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,System.Single)">
            <summary> Burn calories or fail if not enough available. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.BurnFuel(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Components.FuelSupplyComponent,System.Single)">
            <summary> Burn fuel or fail if not enough available. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.RemoveFromInventory(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Inventory,System.Type)">
            <summary> See if we can remove an item, and queue it for post if so. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.ClaimOrUnclaimProperties(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Property.Deed,Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos},System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos},System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Claim/unclaim combo operation for lists for plot positions in PLOT-SPACE to claim/unclaim.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.PlaceBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Type,System.Type,System.Boolean,Eco.Gameplay.Items.Inventory,System.Type)">
            <summary> Uses tool to place blocks of provided type on the target area. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DeleteBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Item,System.Boolean,System.Action{Eco.Gameplay.Objects.RubbleObject},System.Boolean,System.Boolean)">
            <summary> Add the deletion of blocks to the passed action pack and use tool, if able. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.ChangeBlock(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Type)">
            <summary> Uses tool to change type of blocks in the area. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.UseTool(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Single)">
            <summary> Consume energy, use durability and gain XP if related params are provided. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DestroyPlant(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Simulation.DeathType,Eco.Gameplay.Items.Inventory,System.Func{Eco.Simulation.Types.PlantSpecies,System.Boolean})">
            <summary> Destroy plants in the area. Will use the tool (i.e. reduce durability, try give XP and burn calories). </summary> // Use DestroyPlantInternal if you don't want to trigger UseTool.
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.HarvestPlant(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Gameplay.Items.Inventory,System.Boolean)">
            <summary> Harvest a PlantEntity into provided inventory. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.DoNow(System.Action{Eco.Gameplay.GameActions.GameActionPack},System.Boolean)">
            <summary> Helper for calling the 'Now' functions immediately. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.AtomicActions.PerformMultiblockToolAction(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.GameActions.MultiblockActionContext,System.Func{Eco.Shared.Math.WrappedWorldPosition3i,Eco.Core.Utils.Result})">
            <summary> Executes provided actions for each position and counts successful to invoke UseTool with that value as a multiplier. Fails only if nothing was performed. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.MultiblockActionContext">
            <summary> Parameters, the presence of which will determine behavior of multi-block atomic action.
            Default values will be ignored, i.e. if there is no fuel component provided, then nothing will be burned. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.BlockUtils.GetItem(Eco.World.Blocks.Block)">
            <summary> Tries to convert object into an item. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.ISyncedAction">
            <summary> An action that should be run in synced way. Both with "IPretestAction" works to avoid bugs with simultaneous running of two actions, like pick up same item twice by different users. Pair of (syncObject, GameActionType) will be locked while action is running.</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.AggregatableAction">
            <summary> This is base class for all actions which can be grouped for optimization reasons. It already generates GetGroupingKey via reflection based on attributes and config of stats. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionDescription">
            <summary>
            Wraps Game Action descriptions that are visible to the players in two tenses.(Simple tense and progressive tense).
            </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionExtensions">
            <summary>Extension for game actions.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionExtensions.AffectedDeeds(Eco.Gameplay.GameActions.GameAction)">
            <summary>Check location permissions. Get all the affected plots.  Some actions may affect multiple plots.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionExtensions.Fill(Eco.Gameplay.GameActions.GameAction,Eco.Gameplay.GameActions.MultiblockActionContext,Eco.Shared.Math.WrappedWorldPosition3i,Eco.Gameplay.Items.Item)">
            <summary> Tries to fill action's fields with the provided data. </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionManager.GameActionLockers">
            <summary> Saves locks for combination of game action type and action subject (defined by ISyncedAction). It means that it will prevent running at same time same action with same subject, like two action of pick up same world object.
            It needs to be converted from tuple to GameActionLocker since tuple is value type, and locks works in base of reference (i.e. (object, type) would never prevent nothing, since each time when it's used it will just create new reference) /// </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.NoLawsAttribute">
            <summary> Prevents an action from being tracked in laws. </summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.GameActionPack">
            <summary>
            In Eco many actions can be blocked or modified by laws. This is handled with the GameActionPack, which defines an action to try to run,
            and a set of 'PostEffects' that subsequently run if it succeeds, as well as objects to dispose on completion. These packs are created then
            passed to the GameActionManager to perform them. 
            </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.GameActions">
            <summary> GameActions that are put through laws, auth, and stats. </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.PreTests">
            <summary> Pretests to be run once the entire game action has been build and is being performed.  This is used for things like changelists, which might have multiple 
            things added throughout the compilation of the GameActionPack, and thus shouldn't be tested for early-out. Usually though, things can fail in early-outs. </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.PostEffects">
            <summary> Code to run when everything succeeds. These may not fail. </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.OnDispose">
            <summary> Other disposal actions. </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.ChangeSets">
            <summary> collection of ChangeSet, there is only one change set for each type. They are used to do pretests, add PostEffect or called dispose call back</summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.EarlyResult">
            <summary> If an action fails early, this will be set, preventing further atomic actions from bothering to do anything. </summary>
        </member>
        <member name="F:Eco.Gameplay.GameActions.GameActionPack.Locker">
            <summary> Locking object of gameactionpack. Sample: When pick up same item, it will be locked, so another similar action (pick up) with same item will block each other, still allowing different things interact with this item. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPack.#ctor(Eco.Gameplay.GameActions.GameAction,System.Action)">
            <summary> Wrapper that lets us attach post-effects that don't need to return a status. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPack.AddChangeSet(Eco.Gameplay.GameActions.IGameActionPackChangeSet)">
            <summary> Changesets need to be cleaned up afterwards. </summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionPackExtension.GetOrCreateInventoryChangeSet(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Players.User)">
            <summary>This is an particular extension only for InventoryChangeSet to get or create a ChangeSet from a GameActionPack with inventory and user</summary>&gt;
        </member>
        <member name="M:Eco.Gameplay.GameActions.GameActionUtils.GetSettlementsWithJurisdiction(Eco.Gameplay.GameActions.GameAction)">
            <summary>Return all settlements which have jurisdiction of this game action.  These are settlements
            whose laws affect it.</summary>
        </member>
        <member name="T:Eco.Gameplay.GameActions.IGameActionPackChangeSet">
            <summary>Objects with this interface will be used in GameActionPack to do PreTest, PostEffect or GameActionPack Dispose callback.</summary>
        </member>
        <member name="M:Eco.Gameplay.GameActions.TriggerConfigManager.IsValidConfig(System.Reflection.PropertyInfo,System.Type)">
            <summary> Checks if property is a valid property to appear on the Trigger section.</summary>
        </member>
        <member name="T:Eco.Gameplay.Housing.PropertyValues.PropertyValue">
            <summary>Determines the property value of a given deed, given whats built on it.</summary>
        </member>
        <member name="M:Eco.Gameplay.Housing.PropertyValues.PropertyValue.CalcValueAndNotify(Eco.Gameplay.Property.Deed)">
            <summary> Calculate the value of the property.</summary>
        </member>
        <member name="M:Eco.Gameplay.InfluenceObjects.InfluenceManager.MapUpdated(System.Object)">
            <summary>This must be called after an influence map is changed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.AsyncInteractResult">
            <summary> Interaction result with async result. It behaves like NoOp <see cref="T:Eco.Gameplay.Interactions.InteractResult" /> if not resolved, 
            but actual result may be obtained from <see cref="P:Eco.Gameplay.Interactions.AsyncInteractResult.Task" /> or with <see cref="M:Eco.Gameplay.Interactions.AsyncInteractResult.Resolve(Eco.Gameplay.Interactions.InteractResult)" /> for either 
            <see cref="T:Eco.Gameplay.Interactions.InteractResult" /> or <see cref="T:Eco.Gameplay.Interactions.AsyncInteractResult" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.AsyncInteractResult.MakeResultFromTask(System.Threading.Tasks.Task{Eco.Gameplay.Interactions.InteractResult})">
            <summary>Make a result from a task, with a regular InteractResult if its already done, and an async result otherwise.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.AsyncInteractResult.Task">
            <summary> <see cref="T:System.Threading.Tasks.Task" /> which should be completed to get actual result. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.AsyncInteractResult.Resolve(Eco.Gameplay.Interactions.InteractResult)">
            <summary> Resolves <see cref="T:Eco.Gameplay.Interactions.InteractResult" /> to <see cref="T:System.Threading.Tasks.ValueTask`1" />. If <paramref name="result" /> is async result 
            then it will contain <see cref="P:Eco.Gameplay.Interactions.AsyncInteractResult.Task" /> otherwise it will be resolved to <paramref name="result" /> itself. </summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.IInteractable">
            <summary>
            An object that can be interacted with by the player.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractable.OnActLeft(Eco.Gameplay.Interactions.InteractionContext)">
            <summary> An interaction from the left mouse button. eg Using a hammer to pick up a block. If it returns
            InteractResult.NoOp then the interaction manager will move on to the next tool/item in the interaction
            list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractable.OnActRight(Eco.Gameplay.Interactions.InteractionContext)">
            <summary> An interaction from the right mouse button. eg Placing a block.  If it returns
            InteractResult.NoOp then the interaction manager will move on to the next tool/item in the interaction
            list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractable.OnActInteract(Eco.Gameplay.Interactions.InteractionContext)">
            <summary> An interaction from pressing the E key. eg Opening up a world objects UI.  If it returns
            InteractResult.NoOp then the interaction manager will move on to the next tool/item in the interaction
            list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractable.OnPreInteractionPass(Eco.Gameplay.Interactions.InteractionContext)">
            <summary> Executes during first pass for interaction for all methods, used as early filtering
            for interactables  (to quickly skip undesired interactions). Requires InteractResult.Fail to exclude,
            InteractResult.NoOp will just do nothing for this check.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractable.GetInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">
            <summary> Get the default interactions available on this object. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractableExtensions.GetFinalInteractiveDescs(Eco.Gameplay.Interactions.IInteractable,Eco.Gameplay.Interactions.InteractionContext)">
            <summary> Check if this object implements <see cref="T:Eco.Gameplay.Interactions.IOverridableDescription" /> interface first and possibly return
            <see cref="M:Eco.Gameplay.Interactions.IDescriptionChild.GetChildInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">child's description</see>
            instead of the default one. </summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.IOverridableDescription">
            <summary> Allows others to override <see cref="M:Eco.Gameplay.Interactions.IInteractable.GetInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">default description</see> 
            of this interactable. For a demo see how <see cref="M:Eco.Gameplay.Components.ItemDistributionComponent.Initialize">distribution component
            adds itself </see> to <see cref="P:Eco.Gameplay.Components.StorageComponent.DescriptionChildren">storage component's description children</see>,
            so the world object's <see cref="M:Eco.Gameplay.Interactions.IInteractable.GetInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">final description</see> will be depending on the
            <see cref="M:Eco.Gameplay.Components.ItemDistributionComponent.ShouldOverrideDescription(Eco.Gameplay.Interactions.InteractionContext)">declared condition</see>.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.IOverridableDescription.DescriptionChildren">
            <summary><see cref="M:Eco.Gameplay.Interactions.IOverridableDescription.GetChildDescription(Eco.Gameplay.Interactions.InteractionContext)">GetChildDescription</see> will <see cref="M:Eco.Gameplay.Interactions.IDescriptionChild.ShouldOverrideDescription(Eco.Gameplay.Interactions.InteractionContext)">
            check</see> whether this object's <see cref="M:Eco.Gameplay.Interactions.IInteractable.GetInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">default description</see> should be overridden.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IOverridableDescription.GetChildDescription(Eco.Gameplay.Interactions.InteractionContext)">
            <summary>Check if any of children should override parent's description.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.IDescriptionChild">
            <summary> Allows to add this child to some <see cref="T:Eco.Gameplay.Interactions.IOverridableDescription" /> and replace its
            <see cref="M:Eco.Gameplay.Interactions.IInteractable.GetInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">default description</see> with a <see cref="M:Eco.Gameplay.Interactions.IDescriptionChild.GetChildInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">
            description on this child</see> if the <see cref="M:Eco.Gameplay.Interactions.IDescriptionChild.ShouldOverrideDescription(Eco.Gameplay.Interactions.InteractionContext)">declared condition</see>
            returns true (see <see cref="M:Eco.Gameplay.Components.ItemDistributionComponent.ShouldOverrideDescription(Eco.Gameplay.Interactions.InteractionContext)">
            distribution component's implementation</see> for a demo).</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IDescriptionChild.ShouldOverrideDescription(Eco.Gameplay.Interactions.InteractionContext)">
            <summary>Check if this child's description should be used instead of parent's 
            <see cref="M:Eco.Gameplay.Interactions.IInteractable.GetInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">default description</see>.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IDescriptionChild.GetChildInteractiveDescs(Eco.Gameplay.Interactions.InteractionContext)">
            <summary>Get the interactions available on this child.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.IInteractableObject.InteractDistance">
            <summary> Maximum distance away where the player can interact with the object. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractableObject.CanInteractFrom(Eco.Shared.Math.Vector3,Eco.Shared.Items.InteractionInfo,System.Single)">
            <summary>Checks if the object can be interacted from <paramref name="fromPosition" /> (usually Player position) with provided interaction <paramref name="info" />. It uses <paramref name="maxDistance" /> to check if <paramref name="fromPosition" /> is close enough to the object.</summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.IInteractionChecker">
            <summary>
            Add this interface to interactable object or component which can check if interaction at specific position is valid.
            IInteractableObject inherits this interface with default implementation and uses object position for checks, but in some cases
            (like for Elevator Cabin which is moving away from object's position) it isn't enough and the component should provide additional interaction positions.
            When check performed it will check until at least one interaction allowed, if all disallowed then interaction prohibited.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.IInteractionChecker.CanInteract(Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,Eco.Shared.Items.InteractionInfo)">
            <summary>
            Checks if object at <paramref name="objectPosition" /> may be interacted at <paramref name="interactPosition" /> (with provided interaction <paramref name="info" />).
            Usually it means that <paramref name="interactPosition" /> should be within bounds of the object at <paramref name="objectPosition" />.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.InteractionContext">
            <summary>
            All the information for an interaction.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Method">
            <summary> Method used to start the interaction. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Modifier">
            <summary> Any modifier key held down while triggering the interaction. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Target">
            <summary> The object being interacted with, if set. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Block">
            <summary> The targeted block, if set. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.InteractableBlock">
            <summary> Returns the blocks IInteractableObject interface, if the blocks is set and interactable. Priority #3. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.BlockPosition">
            <summary> The position of the targeted block, if set. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Player">
            <summary> The player making the interaction. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.ToolbarInventory">
            <summary>Reference to the inventory's contents. Ie. The player's toolbar inventory item slots.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.BuilderInventory">
            <summary>Reference to the builder inventory's contents. Ie. The player's single carried item slot. Eg. Carrying Hewn Logs.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.CanPickupBuilderInventory">
            <summary>True if the inventory has room.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.SelectedItem">
            <summary> A tool or item selected in the action bar. Priority #2. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.SelectedStack">
            <summary>The <see cref="T:Eco.Gameplay.Items.ItemStack" /> that the player's toolbar currently has selected.</summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.CarriedItem">
            <summary> An item being carried. Priority #4. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.HitPosition">
            <summary> When interacting with an object, the position where the interaction ray intersected the object's collider. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Distance">
            <summary> Distance to the interaction target. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Normal">
            <summary> The facing direction of the side of the selected block. This is the side any placed block will be. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.FacingDirection">
            <summary> The facing direction of the player when performing the action. </summary>
        </member>
        <member name="P:Eco.Gameplay.Interactions.InteractionContext.Parameters">
            <summary> Custom interaction parameters. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.InteractionContext.TryGetBlockPosition(Eco.Shared.Math.WrappedWorldPosition3i@)">
            <summary>Tries to convert <see cref="P:Eco.Gameplay.Interactions.InteractionContext.BlockPosition" /> to <see cref="T:Eco.Shared.Math.WrappedWorldPosition3i" /> if it exists and valid.</summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.InteractionExtensions.ExecuteUntilSuccess``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Eco.Gameplay.Interactions.InteractResult})">
            <summary> Runs through a list of list of interaction functions, stopping when one succeeds. If the
            function returns an error result it will be stored and returned if no other function succeds. </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.InteractionExtensions.PrioritisedInteractables(Eco.Gameplay.Interactions.InteractionContext)">
            <summary>
            Return all the interactables in the given context ordered by preferred interaction priority:
                1. Target.
                2. Selected item (action bar).
                3. Interactable block.
                4. Carried item.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Interactions.InteractResult">
            <summary>
            The result of an interaction. If it is a failure it also contains an error message for the player.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Interactions.InteractResult.NoOpWithReason(Eco.Shared.Localization.LocString)">
            <summary> Creates NoOp InteractResult, but with reason why operation not performed. It differs from <see cref="M:Eco.Gameplay.Interactions.InteractResult.Failure(Eco.Shared.Localization.LocString)" /> for <see cref="M:Eco.Gameplay.Interactions.InteractionExtensions.ExecuteUntilSuccess``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Eco.Gameplay.Interactions.InteractResult})" />, because doesn't stop chain, but provides detailed description if no operation was performed. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.AuthorizationInventory">
            <summary> Inventories of this type should be used when they can be accessed by other players.
            It's also possible to adjust authorization flags for some non-standard scenarios. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.AuthorizationInventory.AuthorizationFlags">
            <summary> These flags allow to forbid or allow some scenarios when players interact with <see cref="T:Eco.Gameplay.Items.AuthorizationInventory" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.BlockItem.GetBlockItem(System.Type)">
            <summary> Returns <see cref="T:Eco.Gameplay.Items.BlockItem" /> for requested <paramref name="blockType" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.BlockItem.PlaceBlockUnstacked(Eco.Gameplay.Interactions.InteractionContext,Eco.Shared.Math.Vector3i)">
            <summary> Place a block unstacked, needs unoccupied space. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.BlockItem.PlaceBlockStacked(Eco.Gameplay.Interactions.InteractionContext,Eco.World.Blocks.Block,Eco.Shared.Math.Vector3i)">
            <summary> Place a block in an existing stack. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ClothingInventory.SwapInventories(Eco.Gameplay.Players.Player,Eco.Gameplay.Items.ClothingInventory)">
            <summary> Swap not hidden clothing between two inventories (empty slots are swapping too) </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IEcopediaEntry">
            <summary> Interface for <see cref="T:Eco.Core.Systems.IRegistrar" /> entries which may be shown in Ecopedia. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.IEcopediaEntry.IsVisibleInEcopedia">
            <summary> Returns if this entry should be displayed in Ecopedia. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IInventoryChangeSet.MoveStacks(Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Items.ItemStack)">
            <summary> Move the source stack items to the destination, combining/swapping depending on the items. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IInventoryContext">
             <summary>
             Used by <see cref="T:Eco.Gameplay.Components.VehicleComponent" /> to override the <see cref="T:Eco.Gameplay.Players.Player" />'s inventory context when mounted in a vehicle.
             <para>An inventory context can be overriden by setting InventoryContext or BuilderInventoryContext to the new inventory object that needs to be used.</para>
            
             <para>The context is used by <see cref="T:Eco.Gameplay.Components.StorageComponent" /> to read what contents are in the <see cref="T:Eco.Gameplay.Players.Player" />'s inventories.</para>
            
             <para>Ex. <see cref="T:Eco.Gameplay.Components.CraneToolComponent" /> overrides it's vehicles BuilderInventoryContext with its own ClawInventory so <see cref="T:Eco.Gameplay.Components.StorageComponent" />
             will use the crane's builder inventory instead of the player's when mounted.</para>
             </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.IInventoryContext.InventoryContext">
            <summary>The toolbar inventory context. Handles ItemStacks and selecting.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.IInventoryContext.BuilderInventoryContext">
            <summary>The builders inventory context. Handles items that need to be picked up.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryComponent">
            <summary>
            Inventory components track an attribute of an inventory, such as weight
            restrictions may use components to handle valid item destinations
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.WeightComponent">
            <summary>Used to track the total weight of an inventory.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.WeightComponent.MaxWeight">
            <summary>Represents the max weight this inventory can support.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.WeightComponent.Weight">
            <summary>Represents the true modified weight of this inventory.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.TryRemoveItemsAsManyAsPossible(System.Type,System.Int32,Eco.Gameplay.Players.User)">
            <summary>Remove as much as we can, up to desired quantity, and return results.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.GetMaxAccepted(Eco.Gameplay.Items.Item,System.Int32,Eco.Gameplay.Items.InventoryChangeSet,Eco.Gameplay.Items.Inventory)">
            <summary>
            Get the maximum amount of item are allowed to put into this inventory
            </summary>
            <param name="item"></param>
            <param name="currentQuantity">Current quantity of the Item in the Inventory</param>
            <param name="changeSet">Data of the current transfer</param>
            <param name="sourceInventory"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.GetMaxPickup(Eco.Gameplay.Items.Item,System.Int32,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Inventory)">
            <summary>
            Check restrictions based on general data (for use outside changesets, some general pre-checks, etc).
            Get the maximum amount of items are allowed to pick up from the current Item stack
            </summary>
            <param name="item">Items that are being transferred</param>
            <param name="currentQuantity">Current quantity of the Item in the Inventory</param>
            <param name="user"></param>
            <param name="targetInventory"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.CheckRestrictions(Eco.Gameplay.Items.Inventory.RestrictionCheckType,Eco.Gameplay.Items.Item,System.Int32,System.Func{Eco.Gameplay.Items.InventoryRestriction,System.Int32},Eco.Gameplay.Items.InventoryRestriction@)">
            <summary>Used to check restriction violations affecting the move of an item for this inventory.
            Provides the strongest/most important restriction for further processing and returns the maximum amount this inventories stacks may accept of this item.</summary>
            <param name="checkType">The type of the operation (MaxPickup/MaxAccepted) that the restrictions are checked for.</param>
            <param name="item">The item that is being moved.</param>
            <param name="currentQuantity">The quantity that the stack currently holds.</param>
            <param name="checkMethod">The method used to check the restrictions: either MaxPickup or MaxAccepted.</param>
            <param name="strongestRestriction">If the move got restricted, assuming there might be multiple restrictions, the strongest/most important one will be provided with this out variable.</param>
        </member>
        <member name="M:Eco.Gameplay.Items.Inventory.TryGetBestRestrictionMessage(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.InventoryRestriction},Eco.Shared.Localization.LocString@)">
            <summary>Given a set of violated restrictions, will try to resolve a message that best describes all restrictions altogether.
            TODO: This was introduced as a quick fix for Store. Eventually inventory moves/restrictions/messages have to be rebuilt to keep a context of the initiating action.</summary>
            <param name="violatedRestrictions">A set of violated restrictions to use for resolution.</param>
            <param name="message">The generated message.</param>
            <returns>If a specialized message could be produced or not.</returns>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryChangeSet">
            <summary>A collection of modifications we wish to perform on an inventory</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.ConsolidateInventory(Eco.Gameplay.Items.Inventory,Eco.Gameplay.Players.User)">
            <summary>
            Consolidate <paramref name="inventory" /> items into least amount of stacks.
            Unique items are not consolidated.
            </summary>
            <param name="inventory"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.CheckAuthForMove(Eco.Gameplay.Players.User,Eco.Gameplay.Items.Inventory,Eco.Gameplay.Items.Inventory,System.Type,System.Int32@)">
            <summary> Checks if user authorized to move stacks between inventories and adjust allowed quantity for inventories with restricted amount (i.e. for distribution station). </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryChangeSet.RemoveAsMuchAsPossible(Eco.Gameplay.Items.Stackable,System.Int32)">
            <summary> Tries to remove as much as possible <paramref name="stackable" /> up to <paramref name="requested" />. </summary>
            <returns> Returns all removed items with count. </returns>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryRelated.InventoryManager">
            <summary>Tracks all inventories so that they can be scanned for items.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryAccessType">
            <summary>Used to describe the access type of inventory (are we using in with player hands or from vehicle tool, etc)</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.RestrictionType">
            <summary>This helps in preparing a simple contextual error message for invalid inventory move (when all stacks produced a restriction).
            See <see cref="M:Eco.Gameplay.Items.Inventory.TryGetBestRestrictionMessage(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.InventoryRestriction},Eco.Shared.Localization.LocString@)" />.</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.RestrictionType.Space">
            <summary>When everything can be added to the inventory and the only limit is space (currently only serves Stockpile).</summary>
        </member>
        <member name="F:Eco.Gameplay.Items.RestrictionType.Specialized">
            <summary>When only a specilized set of items can be added to the inventory (Fuel/Silo etc.).</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.InventoryRestriction">
            <summary>Restricts an inventory from accepting or applying an operation</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryRestriction.Message">
            <summary>Localized message shown to the user when the restriction checks do not pass.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRestriction.MaxAccepted(Eco.Gameplay.Items.Item,System.Int32)">
            <summary>Custom handler for defining restriction max accepted rules.</summary>
            <returns>The max amount of of items that can be accepted. Otherwise -1 for default behaviour.</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRestriction.MaxPickup(Eco.Gameplay.Items.RestrictionCheckData,Eco.Gameplay.Items.Item,System.Int32)">
            <summary>Custom handler for defining restriction pickup rules.</summary>
            <returns>The max amount that can be picked up. Otherwise -1 for default behaviour.</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryRestriction.MaxAccepted(Eco.Gameplay.Items.RestrictionCheckData,Eco.Gameplay.Items.Item,System.Int32)">
            <inheritdoc cref="M:Eco.Gameplay.Items.InventoryRestriction.MaxAccepted(Eco.Gameplay.Items.Item,System.Int32)" />
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryRestriction.Priority">
            <summary>The priority of the restriction. Used to find the most important restriction (<see cref="M:Eco.Gameplay.Items.Inventory.CheckRestrictions(Eco.Gameplay.Items.Inventory.RestrictionCheckType,Eco.Gameplay.Items.Item,System.Int32,System.Func{Eco.Gameplay.Items.InventoryRestriction,System.Int32},Eco.Gameplay.Items.InventoryRestriction@)" />)
            from all of the applied restrictions for a given inventory stack.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.InventoryRestriction.Type">
            <summary>See <see cref="T:Eco.Gameplay.Items.RestrictionType" /></summary>
        </member>
        <member name="T:Eco.Gameplay.Items.PutOnlyRestriction">
            <summary>Prevents a user from picking up items from an inventory.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ItemTypeLimiterRestriction">
            <summary>Restricts an inventory instnace to only accept items matching the given types. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.NoAddRestictions">
            <summary>Prevents the inventory from accepting anything.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.CarriedRestriction">
            <summary>Restricts an inventory instance to only accept items carried.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.NoBuildingRestriction">
            <summary>Restricts the inventory from accepting building materials.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.DurabilityRestriction">
            <summary>Restricts the inventory to only accept items that need to be repaired</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.NotCarriedRestriction">
            <summary>Restricts the inventory to only accept items that are not carried.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.WeightRestriction">
            <summary>Prohibts the inventory Prohibits from accepting items beyond the weight limit</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.FuelRestriction">
            <summary>Restricts the inventory to only accept fuel items.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SeedRestriction">
            <summary>Restricts the inventory to only accept items that are seeds</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SpecificItemTypesRestriction">
            <summary>Restricts the inventory to only accept specific items</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.TagRestriction">
            <summary>Restricts the inventory to only accept items that match the given tags.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.StackableRestriction">
            <summary>Restricts an inventory so it can only accept specific stackable items.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ClothingRestriction">
            <summary>Restricts an inventory to only accept fitting a specific slot</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.StackLimitRestriction">
            <summary>Limits the inventory stack sizes to a different quantity than <see cref="P:Eco.Gameplay.Items.Item.MaxStackSize" /></summary>
        </member>
        <member name="P:Eco.Gameplay.Items.StackLimitRestriction.MaxItems">
            <summary>The maximum stack size allowed by the restriction.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.StackLimitRestriction.StaticLimit">
            <summary>If true this inventory restriction will not apply external modifiers to its settings.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.StackLimitTypeRestriction">
            <summary>Limit the inventory stack sizes to a different quantity than <see cref="P:Eco.Gameplay.Items.Item.MaxStackSize" /> depending on item type table</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SiloRestriction">
            <summary>Sets an inventory to only accept items with tag seeds, crops, or fertilizer</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.FoodStorageRestriction">
            <summary>Sets an Inventory to only accept food tag items</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.SettlementRestriction">
            <summary>Sets an inventory to only accept items matching a specific settlement, for items associated with settlements</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryUtils.CanMoveItems(Eco.Gameplay.Items.Inventory,System.Type,System.Int32,Eco.Gameplay.Players.User,System.Int32@)">
            <summary> Checks whether it's possible for the <paramref name="user" /> to perform changes in this inventory. </summary>
            <param name="inventory"></param>
            <param name="itemType"> Some inventories can allow to move item of specific types (like in workables). </param>
            <param name="allowedQuantity"> Amount of items being moved, absolute value. The value may be adjusted by some restrictions (like in item distribution component). </param>
            <param name="delta"> Signed amount of items being moved. </param>
            <param name="user"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.InventoryUtils.TryGetFirstStackMatchingOrEmpty(Eco.Gameplay.Items.Inventory,System.Func{Eco.Gameplay.Items.Item,System.Boolean},Eco.Gameplay.Items.ItemStack@)">
            <summary>Tries to find first stack matching <paramref name="predicate" /> or if not found then uses first empty stack. It may fail if inventory is full.</summary>
            <returns><c>true</c> if either matching or empty stack was found; <c>false</c> if inventory is full and no matching stack.</returns>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStack.ModifyFractional(Eco.Gameplay.Items.Item,System.Single)">
            <summary>Modifies item together with it's <see cref="P:Eco.Gameplay.Items.ItemStack.FractionalQuantity" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStack.Deconstruct(Eco.Gameplay.Items.Item@,System.Int32@)">
            <summary> Deconstructs <see cref="T:Eco.Gameplay.Items.ItemStack" /> into <see cref="P:Eco.Gameplay.Items.ItemStack.Item" /> and <see cref="P:Eco.Gameplay.Items.ItemStack.Quantity" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStackExtensions.CountItems(System.Collections.Generic.IEnumerable{Eco.Gameplay.Items.ItemStack},System.Type)">
            <summary>Sumes quantities of items matching type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemStackExtensions.TryRemove(Eco.Gameplay.Items.ItemStack,System.Int32)">
            <summary>Subtract what we can and return the number removed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ToolbarBackpackInventory">
            <summary>Represents the player's combined toolbar and backpack inventories.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.UserInventory.SendInventoryNotification(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,System.Int32}},System.Collections.Generic.List{Eco.Gameplay.Items.ItemStack})">
            <summary>Send notifications for items added in inventory</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.UserInventory.GetNotificationPosition(Eco.Gameplay.Items.Inventory)">
            <summary>Returns Instant Notification position depending on Inventory type</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.Item">
            <summary>Base class for all inventory friendly items inside Eco.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.DisplayName">
            <summary> Returns display name for given item. This name same as class Display Name and should be specified as [LocDisplayName] attribute. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.WeightWithoutModifiers">
            <summary>Represents the true weight of this item as intended by the item's designers.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.Weight">
            <summary>Represents the <see cref="P:Eco.Gameplay.Items.Item.WeightWithoutModifiers" /> if this item with player defined modifiers attached.</summary>
        </member>
        <member name="P:Eco.Gameplay.Items.Item.HasWeight">
            <summary>Flag determining if this item instance has associated weight.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemAttribute.TryGet``1(System.Type,``0@)">
            <summary> Tries to get item attribute of requested type. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IconGroup">
            <summary>
            Grouping for icons exported to text files.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.AirPollutionAttribute">
            <summary> Attribute for items which makes an World Object with Air Pollution. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.LiquidProducerAttribute">
            <summary> Attribute for items which produces Liquid (or Gases). </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.MaxStackSizeAttribute.Default">
            <summary>Controls the default maximum stack size of items. Override this to change the global stack size of items that don't already have an instance of <see cref="T:Eco.Gameplay.Items.MaxStackSizeAttribute" />. Defaults to 100.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.CanMakeBlockFormAttribute">
            <summary> This tool can make forms, based on its tier. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.CarryTypesLimitedAttribute">
            <summary>
            When the given item can only hold specific items, such as the shovel.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.LawsDropdownIgnoreAttribute">
            <summary>
            To ignore some items in laws picker.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.ItemPersistentData">
            <summary>Contains the persistent data for each component deriving IPersistentData, allowing that data to be preserved preserved and
            restored as the object is placed and put down. This is stored on the WorldObjectItem when the WorldObject is picked up, and on the WorldObject 
            itself when it's placed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.Clear">
            <summary> Internal way of cleaning. Completely removes all entries without any checks. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.ClearOnRequest(Eco.Gameplay.Players.Player)">
            <summary> Cleaning requested by the player. Notifies entries with <see cref="T:Eco.Gameplay.Items.IClearRequestHandler" /> interface 
            and removes all entries without <see cref="T:Eco.Gameplay.Items.IClearRequestHandler" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.ClearOnTrade">
            <summary> Removes all entries with <see cref="T:Eco.Gameplay.Items.IClearOnTrade" /> interface. It also will call <see cref="M:Eco.Gameplay.Items.IPermanentDestroyHandler.OnPermanentDestroy" /> for all such entries which implements <see cref="T:Eco.Gameplay.Items.IPermanentDestroyHandler" /> interface. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.RemoveEntries(System.Func{System.Object,System.Boolean})">
            <summary> Removes all entries matching <paramref name="filter" />. It also will call <see cref="M:Eco.Gameplay.Items.IPermanentDestroyHandler.OnPermanentDestroy" /> for all such entries which implements <see cref="T:Eco.Gameplay.Items.IPermanentDestroyHandler" /> interface. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemPersistentData.DataTooltip(Eco.Gameplay.Players.Player)">
            <summary> Tooltip section with information that this object has been used previously.
            Contains a clickable link to reset object's ersistent data. When hovered, the button shows tooltips of stored entries. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ItemUtils.CanBeStackedOn(Eco.Gameplay.Items.Item,Eco.Gameplay.Items.Item)">
            <summary> Can these items be stacked?  Pays attention to the IUniqueStackable interface, which will allow some unique items to stack. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IPersistentData">
            <summary> This interface is used to store data when an object is transformed into an item and to restore it afterwards. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IClearOnTrade">
            <summary> Item data class with this interface will be removed from <see cref="F:Eco.Gameplay.Items.ItemPersistentData.entries" /> 
            when the item is being sold. For a demo see <see cref="T:Eco.Gameplay.Components.AuthItemData" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IClearRequestHandler">
            <summary> Item data class with this interface will be notified when someone decides to manually reset the item's persistent data (e.g. via a tooltip).
            Result message will be shown to the player. Entries that return failed result will not be removed from the list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IPersistentExtensions.TryHandleClearAndComposeFeedback(Eco.Gameplay.Items.IClearRequestHandler,Eco.Gameplay.Players.Player,Eco.Shared.Localization.LocStringBuilder)">
            <summary> Triggers clear request handler and adds the result message to the provided string builder. Returns handler's bool result. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IPersistentExtensions.CollectWorldObjectPersistentData(Eco.Gameplay.Items.IPersistentData,Eco.Gameplay.Objects.WorldObject)">
            <summary>This will gather IPersistentData components from the object and store them into PersistentData as a ThreadSafeDictionary.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.IPersistentExtensions.AssignWorldObjectPersistentData(Eco.Gameplay.Items.IPersistentData,Eco.Gameplay.Objects.WorldObject)">
            <summary>Takes the data from an item and inserts it into the worldobject being placed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RampItem.DestroyRampBlocks(System.Type[],Eco.Shared.Math.Vector3i[])">
            <summary> Destroys all blocks that belong to a ramp </summary>
            <param name="blockTypes"> Expected types of blocks at matching <paramref name="positions" /> </param>
            <param name="positions"> Positions of all blocks that belong to ramp </param>
            <remarks> Blocks at positions stored in <paramref name="positions" /> will be destroyed if they have type matching same index in <paramref name="blockTypes" /> </remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.RampItem.DestroyRampBlocks(Eco.Shared.Math.Vector3i,Eco.World.Blocks.Ramp,Eco.World.Blocks.Block)">
            <summary> Destroys a ramp </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RampItem.GetRampBlockData(Eco.Gameplay.Items.RampItem,Eco.World.Blocks.Block,Eco.Shared.Math.Vector3i)">
            <summary> Get data about all blocks that belong to a ramp given one of it's blocks and this block's position </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.IngredientElement">
            <summary>Dynamic quantity tag stack.</summary>
            <remarks>Should never be used to represent an actual item.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Items.Recipe.ActivateVariant(Eco.Gameplay.Items.RecipeVariant)">
            <summary> Activates <see cref="T:Eco.Gameplay.Items.RecipeVariant" /> for this recipe. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RecipeFamily.SkillsNeeded">
            <summary> Returns the skills that are needed to craft this recipe, as well as to craft the table this recipe is made on. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.RecipeVariant">
            <summary> Recipe variant with different ingredients which may be activated for <see cref="T:Eco.Gameplay.Items.Recipe" /> based on some conditions (like difficulty settings). </summary>
        </member>
        <member name="F:Eco.Gameplay.Items.RecipeVariant.Presets">
            <summary> Mapping between presets and list of recipe variants for the preset. All these variants will be applied to their recipe families when preset activated (see <see cref="M:Eco.Gameplay.Items.RecipeVariant.ActivatePreset(System.String)" />). </summary>
        </member>
        <member name="F:Eco.Gameplay.Items.RecipeVariant.Ingredients">
            <summary> Set of ingredients for the recipe variant which will replace current set of ingredients when activated. See <see cref="M:Eco.Gameplay.Items.Recipe.ActivateVariant(Eco.Gameplay.Items.RecipeVariant)" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RecipeVariant.Register(System.String,System.Type,Eco.Gameplay.Items.IngredientElement[])">
            <summary>
            Registers <paramref name="recipeFamily" /> default recipe <paramref name="ingredients" /> variant for <paramref name="preset" />.
            Then you can just activate all registered recipe variants for the <paramref name="preset" /> at once with <see cref="M:Eco.Gameplay.Items.RecipeVariant.ActivatePreset(System.String)" />.
            <paramref name="preset" /> may have any value, it is just a reference name you can use to activate variants when required.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RecipeVariant.Register``1(System.String,Eco.Gameplay.Items.IngredientElement[])">
            <inheritdoc cref="M:Eco.Gameplay.Items.RecipeVariant.Register(System.String,System.Type,Eco.Gameplay.Items.IngredientElement[])" />
            <typeparamref name="T" /> is recipe family type.
        </member>
        <member name="M:Eco.Gameplay.Items.RecipeVariant.Register(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,Eco.Gameplay.Items.IngredientElement[]}})">
            <summary> Registers multiple recipe variants for a <paramref name="preset" />. <paramref name="mapping" /> param has mapping between <see cref="T:Eco.Gameplay.Items.RecipeFamily" /> type and set of ingredients for the <paramref name="preset" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.RecipeVariant.RegisterDefault``1(System.String)">
            <summary> Registers default (current, usually from startup) ingredients list of recipe family of type <typeparamref name="T" /> for the <paramref name="preset" />. See <see cref="M:Eco.Gameplay.Items.RecipeVariant.Register(System.String,System.Type,Eco.Gameplay.Items.IngredientElement[])" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Items.TagDefinition">
            <summary> Tag definition which contains additional attributes for tag. May be used by Mods to configure tags for displaying in different sections or filters. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.All">
            <summary> Contains mapping for all tag definitions. Where <c>key</c> is the lowercase tag name and <c>value</c> is <see cref="T:Eco.Gameplay.Items.TagDefinition" /> itself. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.Name">
            <summary> Tag name. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.PluralName">
            <sumary> An optional plural name for tags. </sumary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.ShowInFilter">
            <summary> If the tag should be should in filters. </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.AutoHighlight">
            <summary> If the tag should be auto highlighted (i.e. in chat). </summary>
        </member>
        <member name="P:Eco.Gameplay.Items.TagDefinition.ShowInEcopedia">
            <summary> If the tag should be shown in Ecopedia. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagDefinition.Register(Eco.Gameplay.Items.TagDefinition)">
            <summary> Registers new <see cref="T:Eco.Gameplay.Items.TagDefinition" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.ToolItem.CreateMultiblockContext(Eco.Gameplay.Interactions.InteractionContext,System.Boolean,System.Func{Eco.Gameplay.GameActions.GameAction},System.Boolean)">
            <summary> Builds a MultiblockActionContext based on this item's data. </summary>
            <param name="context"></param>
            <param name="applyXPSkill"> If FALSE, this sets the ExperienceSkill to NULL which results in no AddExperience() post effect being added to the action. </param>
            <param name="gameActionConstructor"></param>
            <param name="highlightCenter"> If FALSE, will apply center position but ignore if it's not highlightable </param>
        </member>
        <member name="M:Eco.Gameplay.Items.ToolItem.CreateMultiblockContext(Eco.Gameplay.Players.Player,System.Boolean,System.Collections.Generic.IEnumerable{Eco.Shared.Math.Vector3i},System.Func{Eco.Gameplay.GameActions.GameAction})">
            <summary> Builds a MultiblockActionContext based on the player's data. </summary>
            <param name="player"></param>
            <param name="applyXPSkill"> If FALSE, this sets the ExperienceSkill to NULL which results in no AddExperience() post effect being added to the action. </param>
            <param name="area"></param>
            <param name="gameActionConstructor"></param>
        </member>
        <member name="M:Eco.Gameplay.Items.GarbageBagBlock.UpdateByInventory(Eco.Gameplay.Items.DecayingInventory)">
            <summary> Updates world with <see cref="T:Eco.Gameplay.Items.GarbageBagBlock" /> corresponding to <paramref name="inventory" /> and returns synced block. </summary>
        </member>
        <member name="F:Eco.Gameplay.Items.WorkOrder.shouldSendNotificationOnHalt">
            <summary> This makes sure that the notification is sent out only one time.
            to handle the case of other work orders of the same type on the crafting table and make it avoid shooting multiple notifications of the same type.
            It is set to false by the first work order to halt and set back to true on preventing only one notification.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.UpdateState">
            <summary> Updates work order state when requirements changes (like resources or labor added). </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.CheckTime(System.Boolean)">
            <summary> Checks if a work order should change state based on its internal timers. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.TryLinkToCraftingComponent(Eco.Gameplay.Components.CraftingComponent)">
            <summary> Tries to link <see cref="T:Eco.Gameplay.Items.WorkOrder" /> to <see cref="P:Eco.Gameplay.Items.WorkOrder.CraftingComponent" /> (usually on load). It may fail if <see cref="T:Eco.Gameplay.Items.WorkOrder" /> is invalid. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.EstimateProducts(System.Int32)">
            <summary> Estimates output products for specified <paramref name="iterations" /> count. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetIterationProducts">
            <summary>
            <p>Gets products for current iteration. It uses scrap for partial product output.
            For last iteration it emits product rounded up, for all other iterations it emits product rounded down with accounting for scrap from previous iterations.</p>
            </summary>
            <sample>
            <p>I.e. for 0.5 Tailing and 5 iterations you will have:</p>
            <li>1. No tailing.</li>
            <li>2. 1 Tailing.</li>
            <li>3. No tailing.</li>
            <li>4. 1 Tailing.</li>
            <li>5. 1 Tailing (last iteration).</li>
            <p>In total you have 2.5 rounded up (to 3).</p>
            </sample>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.DisableSameTypeWorkOrderNotifications">
            <summary>This checks for the crafting component's work orders of same type to disable notifying the user of the issue, since the first work order have the same issue.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.CheckCraftingComponentStatus">
            <summary> Checks if the crafting component's parent is already disabled and sets the work order state accordingly. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetCaloriesPerLaborUnit(Eco.Gameplay.Players.User)">
            <summary> Returns labor units per one calorie using worst user skill's multiplicative strategy. Don't allow to go below 1%. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetMaxIterationsForLaborReservation">
            <summary>
            Returns max iterations for which labor may be reserved.
            For short crafts (less than <see cref="F:Eco.Gameplay.Items.WorkOrder.CraftTimePerLaborReservationUnit" />) it will have more iterations per <see cref="P:Eco.Gameplay.Items.WorkOrder.LaborReservationMultiplier" /> unit.
            For long crafts (greater than or equal to <see cref="F:Eco.Gameplay.Items.WorkOrder.CraftTimePerLaborReservationUnit" />) it will have one iteration per <see cref="P:Eco.Gameplay.Items.WorkOrder.LaborReservationMultiplier" /> unit.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.GetMaxLaborReservation">
            <summary> Returns max labor reservation. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.UpdateAllowedLabor">
            <summary> Updates <see cref="P:Eco.Gameplay.Items.WorkOrder.AllowedLabor" /> using following constraints - at least one ingredient should be added to the craft. After that you can fulfill order with the labor. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.Needs(Eco.Gameplay.Items.Item)">
            <summary> Return true if this or a future iteration needs the given item.</summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorkOrder.CalculateIterationsForAvailableResources(Eco.Gameplay.Items.Inventory)">
            <summary>
            <p>Calculates estimated number of iterations which may be completed with available resources.</p>
            <b>Notice! This method is incredibly slow and should only be used as rare as possible!</b>
            <p>It scans for all linked inventories to find out potential resources and also for all linked components it collects their linked components to get crafting components which may output to
            linked storages.</p>
            <p>It is very rough estimate after all:
            <ul>
            <li>There no guarantee that another crafting component won't output to other not linked inventory;</li>
            <li>There no guarantee that another crafting component won't contribute to another work order;</li>
            <li>There no guarantee items counted in storages won't go to another work order or won't be picked up by player;</li>
            <li>There no guarantee even within single order that counted items won't be used as another ingredient, because they may have match multiple ingredients
            (i.e. have multiple tags which matches different ingredients or may be used as specific item for one ingredient and match by tag for another ingredient).</li>
            </ul></p>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.GetAllObjectsTooltip(Eco.Gameplay.Players.Player)">
            <summary> Generates tooltip displaying list of all world objects created from this item type in the world </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.WorldObjectItem.TryPlaceObject(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,System.Action)">
            <summary> Override this function if you want to have async processing for Place Object action (like asking a citizen for confirmation). </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagExtensions.TagNames(System.Object,System.Boolean)">
            <summary> Returns string collection of object's tags. </summary>
        </member>
        <member name="M:Eco.Gameplay.Items.TagExtensions.GetBestTag(System.Collections.Generic.IEnumerable{System.Object})">
            <summary> Collects tags of entries and tries to find the best match that is present in each of them. </summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.MaintenancePlugin">
            <summary>
            Server plugin instance for handling automatic shutdown/maintenance notifications for Eco Server. This plugin is primarly used by Eco Cloud Worlds but can be used by more advanced server
            administrators. It will automatically post a notification on the configured countdown intervals found in the Maintenance configuration options under <seealso cref="P:Eco.Gameplay.Maintenance.MaintenancePluginConfig.CountdownIntervals" />
            </summary>
            <inheritdoc cref="T:Eco.Core.Plugins.Interfaces.IEditablePlugin" />
            <inheritdoc cref="T:Eco.Core.Plugins.Interfaces.IServerPlugin" />
            <inheritdoc cref="T:Eco.Core.Plugins.Interfaces.IConfigurablePlugin" />
            <inheritdoc cref="T:Eco.Core.Plugins.Interfaces.IThreadedPlugin" />
            <inheritdoc cref="T:Eco.Core.Plugins.Interfaces.IDisplayablePlugin" />
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.UpdateAnnounceIntervals">
            <summary>Updates <see cref="F:Eco.Gameplay.Maintenance.MaintenancePlugin.announceIntervals" /> on init or when config changes to have sorted from lower to greater announce intervals for <see cref="M:Eco.Gameplay.Maintenance.MaintenancePlugin.GetAnnounceRemainingSeconds(System.Int32)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.MaintenanceTick">
            <summary>Tick callback for <see cref="F:Eco.Gameplay.Maintenance.MaintenancePlugin.maintenanceWorker" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.PerformMaintenance(System.DateTime,System.Nullable{Eco.Shared.Localization.LocString}@,System.Boolean@)">
            <summary>Performs maintenance for <paramref name="time" />. Returns delay in milliseconds until next maintenance. Also outputs optional shutdown <paramref name="message" /> and <paramref name="shouldShutdown" /> flag.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.GetAnnounceRemainingSeconds(System.Int32)">
            <summary>Returns remaining time in seconds until next announce for given <paramref name="remainingSeconds" /> time.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.GetShutdownMessage(Eco.Gameplay.Maintenance.ScheduledMaintenance,System.Int32)">
            <summary>Returns shutdown message containing information when shutdown should happen and reason why.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.GetAutomaticMaintenance">
            <summary>Returns a <seealso cref="T:Eco.Gameplay.Maintenance.ScheduledMaintenance" /> representing the current automatic maintenance. Returns default if none is configured.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.TryGetNextMaintenance(System.DateTime,Eco.Gameplay.Maintenance.ScheduledMaintenance@)">
            <summary>Returns next maintenance relative to <paramref name="time" />. The <paramref name="time" /> usually <see cref="P:System.DateTime.UtcNow" />, but may any time if you need to get maintenance relative to time point. It also helps to avoid multiple <see cref="P:System.DateTime.UtcNow" /> calls which may provide different outputs.</summary>
            <returns><c>false</c> if no maintenance available.</returns>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.SendServerNotification(Eco.Shared.Localization.LocString)">
            <summary>Sends a server wide announcement message.</summary>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.ScheduleUserMaintenance(System.DateTime,System.String,System.Boolean)">
            <summary>Schedules a new user defined maintenance period</summary>
            <param name="time"><seealso cref="T:System.DateTime" /> the maintenance shutdown should occur.</param>
            <param name="reason">Message stating reason of shutdown</param>
            <returns><c>true</c> if the maintenance was scheduled. Otherwise returns <c>false</c></returns>
        </member>
        <member name="M:Eco.Gameplay.Maintenance.MaintenancePlugin.CancelUserMaintenance(System.Boolean)">
            <summary>Clears the currently setup user maintenance periods.</summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.MaintenancePluginConfig">
            <summary>Defines the configuration options used by <seealso cref="T:Eco.Gameplay.Maintenance.MaintenancePlugin" /></summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.MaintenancePluginConfig.CountdownIntervals">
            <summary>Defines the announcement countdown intervals in minutes. The 30 second countdown is handled internally by code.</summary>
        </member>
        <member name="T:Eco.Gameplay.Maintenance.ScheduledMaintenance">
            <summary>Represents a scheduled maintenance period.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.ScheduledTime">
            <summary>Defines the date and time of automatic shutdown. This value is in UTC.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.LocalScheduledTime">
            <summary>Defines the date and time of thew automatic shutdown. This value is in local machine time.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.TimeRemaining">
            <summary><seealso cref="T:System.TimeSpan" /> representing the remaining time until maintenance.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.MaintenanceReason">
            <summary>Reason for maintenance/shutdown.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.IsExpired">
            <summary>Boolean flag determining if this maintenance period is expired.</summary>
        </member>
        <member name="P:Eco.Gameplay.Maintenance.ScheduledMaintenance.IsSet">
            <summary>Boolean flag determining if this maintenance period is set.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.Common.ItemRenameMigration">
            <summary><see cref="T:Eco.Gameplay.Migrations.Common.ItemRenameMigration" /> simplifies renaming of <see cref="T:Eco.Gameplay.Items.Item" /> classes. It takes care about item objects (if existed) and existing work orders for that item.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.MigrationDummyBlock">
            <summary>Dummy block without properties/fields for migration purposes. May be used to declare new or intermediate block type.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.MigrationDummyItem">
            <summary>Dummy block without properties/fields for migration purposes. May be used to declare new or intermediate item type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_5.ChatMigration.GetOrCreateChatReceiverByTag(System.String)">
            <summary>Resolves <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver" /> (User or Channel) from <paramref name="tag" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Migrations.V0_9_5.ChatMigration.GetOrCreateChannel(Eco.Gameplay.Migrations.V0_9_5.ChatMigration.Context,System.String)">
            <summary>Gets or creates <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel" /> by name.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_5.ChatMigration.Context">
            <summary>Lazy loading context with all registrars and caches.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_5.GenericGamePickerListMigration">
            <summary> Migrates all existing <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList" />s to <see cref="T:Eco.Gameplay.Civics.GameValues.GamePickerList`1" />, using <see cref="P:Eco.Gameplay.Civics.GameValues.GamePickerList.MustDeriveType" /> as 'T'.</summary>
        </member>
        <member name="T:Eco.Gameplay.Migrations.V0_9_5.StoreOffersToCategoriesMigration9dv5">
            <summary> Migration related to splitting offers by categories at store </summary>
        </member>
        <member name="M:Eco.Gameplay.Minimap.MinimapObjectExtensions.GetUserIds(Eco.Gameplay.Components.MinimapComponent)">
            <summary>Get the Owner id and Creator id of this minimap object</summary>
        </member>
        <member name="M:Eco.Gameplay.Modules.AllowPluginModulesAttribute.GetStackables">
            <summary> Returns <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.Tags" /> and <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.ItemTypes" /> combined into single enumerable. </summary>
            <returns> <c>null</c> if both <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.Tags" /> and <see cref="P:Eco.Gameplay.Modules.AllowPluginModulesAttribute.ItemTypes" /> is null, concatenation of items and tags otherwise. </returns>
        </member>
        <member name="T:Eco.Gameplay.Modules.EfficiencyModule">
            <summary>
            Abstract class for efficiency modules (both resource and speed) which may be used to enhance a table.
            It may only <see cref="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" /> values which associated to same <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" /> or if <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" /> not specified then apply to any value.
            </summary>
            <sample>
            This code creates Hewing Efficiency Module which modifies both resource and speed efficiency and only applies to values associated with HewingSkill.
            <code>
            class HewingEfficiency1 : EfficiencyModule
            {
               public HewingEfficiency1() : base(ModuleTypes.ResourceEfficiency | ModuleTypes.SpeedEfficiency, typeof(HewingSkill), 0.9f) { }
            }
            </code></sample>
        </member>
        <member name="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType">
            <summary> Module will only be applied to values associated with same <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" /> if specified. </summary>
        </member>
        <member name="P:Eco.Gameplay.Modules.EfficiencyModule.GenericMultiplier">
            <summary> Module efficiency generic multiplier (applies to all recipes). Dynamic value in <see cref="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" /> will be multiplied on this to get final value. </summary>
        </member>
        <member name="P:Eco.Gameplay.Modules.EfficiencyModule.SkillMultiplier">
            <summary> Module efficiency skill-related multiplier (only applies to recipes for <see cref="P:Eco.Gameplay.Modules.EfficiencyModule.SkillType" />). Dynamic value in <see cref="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" /> will be multiplied on this to get final value. </summary>
        </member>
        <member name="M:Eco.Gameplay.Modules.EfficiencyModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)">
            <inheritdoc cref="M:Eco.Gameplay.Modules.PluginModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)" />
        </member>
        <member name="T:Eco.Gameplay.Modules.IModule">
            <summary> Interface for in-game modules. Now it is only used for PluginModule, but going to be extended for all module types. Provides API point for modifying dynamic modules within <see cref="T:Eco.Gameplay.DynamicValues.ModuleContext" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Modules.ModuleTypes">
            <summary> Possible <see cref="T:Eco.Gameplay.Modules.PluginModule" /> types. </summary>
        </member>
        <member name="T:Eco.Gameplay.Modules.PluginModule">
            <summary> Base abstract class for plugin modules which may be used as plugin for a table to enhance it in some way (like increase efficiency, extend labor queue etc). </summary>
        </member>
        <member name="P:Eco.Gameplay.Modules.PluginModule.ModuleTypes">
            <summary> Types of the modules (ResourceEfficiency, SpeedEfficiency etc). </summary>
        </member>
        <member name="M:Eco.Gameplay.Modules.PluginModule.Modify(Eco.Gameplay.DynamicValues.ModuleModifiedValue)">
            <summary> Modified <paramref name="value" /> using the module. I.e. if <see cref="P:Eco.Gameplay.DynamicValues.ModuleModifiedValue.ValueType" /> is <see cref="F:Eco.Gameplay.DynamicValues.DynamicValueType.Efficiency" /> then it may be decreased by some percent. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.EcoObjectManager.MarkAsDirty(Eco.Gameplay.Objects.IEcoObject)">
            <summary>
            Marks Eco object as dirty. This object will be saved in background by StorageManager.
            It prevents too often saves for object for often modifications and ensures object will be eventually save latest modifications.
            If object isn't thread-safe for concurrent modifications then use <see cref="M:Eco.Gameplay.Objects.EcoObjectManager.Modify``1(``0,System.Action{``0})" /> instead of make direct changes and call <see cref="M:Eco.Gameplay.Objects.EcoObjectManager.MarkAsDirty(Eco.Gameplay.Objects.IEcoObject)" />.
            </summary>
            <param name="obj">object marked as dirty.</param>
        </member>
        <member name="M:Eco.Gameplay.Objects.EcoObjectManager.Modify``1(``0,System.Action{``0})">
            <summary>
            If Eco object isn't safe for concurrent modifications then instead of using <see cref="M:Eco.Gameplay.Objects.EcoObjectManager.MarkAsDirty(Eco.Gameplay.Objects.IEcoObject)" /> directly make all object modifications inside of modifyAction.
            It also marks object as dirty.
            It will guarantee object won't be saved during modification and no other concurrent modification will be performed to that object.
            </summary>
            <param name="obj">object to modify.</param>
            <param name="modifyAction">action which modifies object.</param>
        </member>
        <member name="T:Eco.Gameplay.Objects.ITickOnDemand">
            <summary>Interface for components (and other objects) which may want to have call to <see cref="M:Eco.Gameplay.Objects.ITickOnDemand.TickOnDemand" /> when closest <see cref="M:Eco.Gameplay.Objects.WorldObjectManager.TickAll" /> happens. It it was added within <see cref="M:Eco.Gameplay.Objects.WorldObject.Tick" /> then it will be processed same tick. They may be registered with <see cref="M:Eco.Gameplay.Objects.IWorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.ITickOnDemand.TickOnDemand">
            <summary>Ticks only when explicitly requested (see <see cref="T:Eco.Gameplay.Objects.ITickOnDemand" /> docs).</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.IWorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)">
            <summary>
            Adds <paramref name="tickable" /> to closest (current or next) <see cref="M:Eco.Gameplay.Objects.WorldObjectManager.TickAll" /> which may not want to tick every time, but instead tick only when specific event happens.
            It may be useful if you wanna delay component state update until tick time, because it may have lot of updates between ticks and processing multiple syncs for every update
            may significantly impact performance. At same time we don't wanna to <see cref="M:Eco.Gameplay.Objects.WorldObjectComponent.Tick" /> every time, because these syncs may not happen for long time
            for most of components and it will just waste CPU time.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.OccupancyHelper.GroundBelow(System.Collections.Generic.List{Eco.Gameplay.Objects.BlockOccupancy},Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>
            Returns positions of ground blocks below the occupancy blocks that have Y offset of 0, 
            if occupancy contains BuildingWorldObjectBlock types only return ground blocks below them
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.OccupancyInfo.GetRange(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion)">
            <summary>Returns <see cref="T:Eco.Shared.Math.WorldRange" /> at <paramref name="origin" /> position and with specified <paramref name="rotation" />. The range is exclusive.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.OccupancyInfo.Contains(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Quaternion,Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3i)">
            <summary>Checks if object at <paramref name="origin" /> position rotated by <paramref name="rotation" /> and with range extended by <paramref name="extraExtents" /> contains <paramref name="position" />.</summary>
        </member>
        <member name="P:Eco.Gameplay.Objects.RubbleObject.PickingUp">
            <summary>This flag should be set when rubble is picking up to prevent concurrent picking same rubble. If you can't set this flag then usually you just need to skip the rubble.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.RubbleObject.Breakup(Eco.Gameplay.Players.Player)">
            <summary> Breaks the chunk of rubble into pieces </summary>
            <returns> List of the rubble pieces </returns>
        </member>
        <member name="M:Eco.Gameplay.Objects.RubbleObject.GetRandomRubble(System.Type)">
            <summary> Returns random rubble type from block's meta info if it exists. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.RubbleObject.Spawn(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3@,System.Action{Eco.Gameplay.Objects.RubbleObject},System.Type[])">
            <summary> Not inteneded to be invoked directly, use atomic actions or public `Try-` accessors. </summary>
        </member>
        <member name="P:Eco.Gameplay.Objects.WorldObject.CachedSettlementAtPos">
            <summary>Get the settlement associate with this world object.  Defined as the lowest level settlement
            that influences this position.  This is cached data built from the influence map.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.CreateEntity">
            <summary> Called when the net entity is created </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.Initialize">
            <summary>Initialize the object and components.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.PostInitialize">
            <summary>For when you have autogen and non-autogen halves of a class that both want to override Initialize. Currently Initalize always happens in the autogen file. Any initalization that happens in PostInitialize will override changes from Initalize.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.ComponentsInitialized">
            <summary>Called after all components have been initialized. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.AddOccupancyRule``1(System.Func{Eco.Gameplay.Objects.WorldObject,System.Collections.Generic.List{Eco.Gameplay.Objects.BlockOccupancy}})">
            <summary>Adds a new dynamic predicate rule to the occupancy dictionary. Note that a predicate rule will be checked first before returning a normal occupancy.</summary>
            <param name="predicate">Takes in a <see cref="T:Eco.Gameplay.Objects.WorldObject" /> instance and returns the occupancies.</param>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.GetOccupancyRangeOrDefault(System.Type)">
            <summary>Returns a world range that encompasses the occupancy. This is an exclusive range.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.GetOccupiedPropertyPositions(System.Type,Eco.Shared.Math.Vector3,Eco.Shared.Math.Quaternion)">
            <summary>Returns all plots intersecting with occupied block positions.</summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.SendUIComponents(Eco.Gameplay.Players.Player)">
            <summary> Sends UI components to the <paramref name="player" />. See <see cref="T:Eco.Gameplay.Objects.WorldObjectComponentClientAvailability" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObject.CanInteract(Eco.Shared.Math.Vector3,Eco.Shared.Math.Vector3,Eco.Shared.Items.InteractionInfo)">
            If world object occupancy check fails then fallback to default check. World Object occupancy should be only check, but requires more testing.
        </member>
        <member name="T:Eco.Gameplay.Objects.BuildingWorldObjectBlock">
            <summary>
            Solid world object block used as a placeholder in occupied blocks. Marked as solid on the client, for builder purposes.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)">
            <inheritdoc cref="M:Eco.Gameplay.Objects.IWorldObjectManager.AddToTick(Eco.Gameplay.Objects.ITickOnDemand)" />
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.IsValidPlacement(Eco.Gameplay.Items.WorldObjectItem,Eco.Shared.Math.Vector3,Eco.Shared.Math.Quaternion)">
            <summary> Checks if it is valid placement for the world object. </summary>
        </member>
        <member name="M:Eco.Gameplay.Objects.WorldObjectManager.DestroyPermanently(Eco.Gameplay.Objects.WorldObject)">
            <summary><list type="number">
            <item> Triggers OnPermanentDestroy on object's components. </item>
            <item> Packs the objects into an item and triggers OnPermanentDestroy on its entries. </item>
            <item> Destroys the object. </item>
            </list></summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.ChimneyComponent.TryGetOutputPosition(Eco.Shared.Math.Vector3i@)">
            <summary>Returns chimney output position if it exits.</summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.ChimneyComponent.IsPipeOutputCloseEnough(Eco.Shared.Math.WrappedWorldPosition3i,Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary>Checks if pipe output it close enough to the object output (within <see cref="F:Eco.Gameplay.Pipes.LiquidComponents.ChimneyComponent.MaxPipeHorizontalOffset" /> by both horizontal axes).</summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.MaxCanReceive(System.Type)">
            <summary> Max (potential) amount of items with <paramref name="itemType" /> which can be received. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.Consume(Eco.Gameplay.Pipes.PipePayload,System.Boolean)">
            <summary> Consumes <paramref name="input" /> optionally using buffer if <paramref name="useBuffer" /> set. If buffer used then all non instantly consumed capacity will go to the buffer. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.TryFlush(System.Single)">
            <summary> Flushed all non-converted amount to converter. Returns <c>false</c> if converter can't accept it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.ConsumeUnchecked(Eco.Gameplay.Pipes.PipePayload,System.Boolean)">
            <summary> Same as <see cref="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.Consume(Eco.Gameplay.Pipes.PipePayload,System.Boolean)" />, but without cycles check. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.SetEnabled(System.Boolean,Eco.Shared.Localization.LocString)">
            <summary> Enables/disables component and updates status. </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.CalculateMaxAmount(System.Single)">
            <summary> Calculates max potentially possible amount to receive. Actual consumed amount may be lower depending on consumer state (disabled, output limited etc). </summary>
        </member>
        <member name="M:Eco.Gameplay.Pipes.LiquidComponents.LiquidConsumerComponent.EnsureAmountWanted">
            <summary> Ensures wanted amount calculated. </summary>
        </member>
        <member name="P:Eco.Gameplay.Plants.PlantEntity.SkillType">
            <summary> The skill this plant should give EXP to when harvested. Null if it doesn't return anything</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantEntity.TryHarvest(Eco.Gameplay.Players.Player,System.Boolean,Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Items.InventoryChangeSet,Eco.Gameplay.Items.Item)">
            <summary> Harvest a plant. </summary>
            <param name="player"></param>
            <param name="picked">True this picked directly (ie pressing E), or false if harvested with a tool.</param>
            <param name="pack"></param>
            <param name="changeSet"></param>
            <param name="tool"></param>
        </member>
        <member name="T:Eco.Gameplay.Plants.PlantGameActions">
            <summary>Plant related game actions.</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantGameActions.TrySeed(Eco.Simulation.Types.PlantSpecies,Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item)">
            <summary>Creates <see cref="T:Eco.Gameplay.GameActions.GameActionPack" />, adds plant seed action to it and tries to perform.</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantGameActions.TrySeedFromInventory(Eco.Gameplay.Items.SeedItem,Eco.Gameplay.Items.Inventory,Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item)">
            <summary>Creates <see cref="T:Eco.Gameplay.GameActions.GameActionPack" />, adds plant seed action to it, removes seed item from inventory and tries to perform.</summary>
        </member>
        <member name="M:Eco.Gameplay.Plants.PlantGameActions.AddSeedAction(Eco.Gameplay.GameActions.GameActionPack,Eco.Simulation.Types.PlantSpecies,Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,Eco.Gameplay.Items.Item)">
            <summary>Adds plant seed action to <paramref name="pack" /> and spawn tended plant as post effect.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.AdditionalUserState`2">
            <summary>
            A mod friendly way of adding additional state to Users.
            </summary>
            <typeparam name="T">The type of the state to save.  Must be convertable to and from a string.</typeparam>
            <typeparam name="TSelf">Self type.</typeparam>
        </member>
        <member name="M:Eco.Gameplay.Players.BaseUserIDList`1.AddAndNotifyOrDescribe(Eco.Gameplay.Players.User,System.String,System.String,System.Nullable{Eco.Shared.Localization.LocString},System.String)">
            <summary>Add user to the collection and notify result or describe result</summary>
            <param name="invoker"></param>
            <param name="targetIdOrName"></param>
            <param name="time">For how long user should stay in the list. If empty : time is five years. Format: 1m, 1h, 1d, 1w</param>
            <param name="listDisplayName"></param>
            <param name="reason"></param>
        </member>
        <member name="M:Eco.Gameplay.Players.BaseUserIDList`1.FindAndAddOrRemoveToList(Eco.Gameplay.Players.User,System.String,System.String,System.Boolean,System.Nullable{Eco.Shared.Localization.LocString},System.String)">
            <summary> Helper that shows elements of the collection or tries to add or remove provided string element (updates config if something was changed). </summary>
        </member>
        <member name="T:Eco.Gameplay.Players.DefaultUserMarkUpService">
            <summary>Default implementation of <see cref="T:Eco.Gameplay.Players.IUserMarkUpService" /> with user name marked up just as UI link.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.ExhaustionMonitor.Energize(System.Single)">
            <summary>Give this user an extra number of hours of energy.  This rolls over.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Food.Cravings.Message">
            <summary> The message describing the craving, shown in tooltip for the user.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.Stomach.Nutrients">
            <summary>The nutrients in our belly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TasteBuds.DoEat(Eco.Gameplay.Players.User,Eco.Gameplay.Items.FoodItem)">
            <summary>Build the string created when eating the item, send any notices if fav/worst food is discovered, and return a string description of it.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.GroupMarker">
            <summary>Wraps world marker to make a single world marker appear to many users.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.IUserAuthorizer">
            <summary>Interface for implementing custom user authorization rules for incoming player connections</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserAuthorizer.AuthorizeSession(Eco.Shared.Authentication.LoginSession)">
            <summary>Checks if the <seealso cref="T:Eco.Shared.Authentication.LoginSession" /> instance is authorized to connect to this server.</summary>
            <param name="session"><seealso cref="T:Eco.Shared.Authentication.LoginSession" /> instance to authorize</param>
            <returns><c>true</c> if the session is authorized. Otherwise <c>false</c> to continue processing.</returns>
        </member>
        <member name="T:Eco.Gameplay.Players.IUserMarkUpService">
            <summary>
            <see cref="T:Eco.Gameplay.Players.IUserMarkUpService" /> is an interface exposed as <c>ServiceHolder{IUserMarkUpService}.Obj</c> for <see cref="T:Eco.Gameplay.Players.User" /> for marking up name, chat tag and name with reputation.
            It exposed to service to make it extendable by Mods (i.e. for custom titles, prefixes etc).
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserMarkUpService.MarkUpName(Eco.Gameplay.Players.User)">
            <summary>Marks up <paramref name="user" /> name.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserMarkUpService.MarkUpChatTag(Eco.Gameplay.Players.User)">
            <summary>Marks up chat tag for <paramref name="user" />. This marked up text used in chat for displaying message sender/recipient</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.IUserMarkUpService.MarkUpReputationAndName(Eco.Gameplay.Players.User)">
            <summary>Marked up name combined with marked up reputation.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.MountManager">
             <summary>
             Handles the player's mounting and dismounting.
            
             <para>Use <see cref="E:Eco.Gameplay.Players.MountManager.MountEvent" /> and <see cref="E:Eco.Gameplay.Players.MountManager.DismountEvent" /> to attach listeners for when the player mounts a vehicle.</para>
             </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MountManager.OnMount(Eco.Gameplay.Components.MountComponent)">
            <summary>Fired when player has mounted a vehicle.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MountManager.OnDismount(Eco.Gameplay.Components.MountComponent)">
            <summary>Fired when player has dismounted a vehicle.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.MovementHackDetector">
            <summary>This class detects when player hacks movement with teleport or increased speed.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.MovementHackDetector.Waypoint">
            <summary>Stores waypoint info for hack detection.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MovementHackDetector.AddWaypoint(System.Numerics.Vector3,System.Single,System.Double)">
            <summary>
            Adds waypoint for player movement. It contains position, max allowed velocity and client timestamp.
            When new waypoint added and if previous waypoint exists then it checks if distance between waypoints reachable with velocity at last waypoint.
            It doesn't check vertical component, because you may fall or jump with higher speed, but it should be fine in most cases.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.MovementHackDetector.Clear">
            <summary>Clears waypoint info. I.e. if you get admin rights and should ignore abnormal movement until admin mode disabled.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.SetMaxAllowedVelocity(System.Nullable{System.Single})">
            <summary>Sets the new MaxAllowedVelocity value. Can be null.</summary>
        </member>
        <member name="F:Eco.Gameplay.Players.Player.Mount">
            <summary>Handles all player vehicle mounting and dismounting logic.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.OpenInfoPanel(System.String,System.String,System.String)">
            <summary> Open info panel </summary>
            <param name="title"></param>
            <param name="text"></param>
            <param name="category"> The category, based on which will be remembered preferred positions and size. </param>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.OptionBox(Eco.Shared.Localization.LocString,System.Collections.Generic.List{System.String})">
            <summary>Shows a dialog with a dropdown.</summary>
            <param name="message">The text to be shown.</param>
            <param name="options">Options to be added to the dropdown.</param>
            <returns>Index of the selected item. -1 if the player cancells the dialog.</returns>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.TryDamage(Eco.Shared.Networking.INetObject,System.Single)">
            <summary> Delegates damage to <see cref="P:Eco.Gameplay.Players.Player.User" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.CheckEmotes(Eco.Shared.Networking.INetClient,Eco.Shared.States.AnimationEmote,Eco.Shared.States.ExpressionEmote)">
            <summary>
            Sends an RPC only to the player who requested the emote. Player will check if possible to play the emote and then notify the server.
            This function is called from a chat command call when a player wants to change their emote.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.Player.ChangeBodyEmote(Eco.Shared.States.AnimationEmote)">
            <summary>
            These RPCs are called from local player (i.e. owner of this Player) after local player checks if it's possible to play the emote.
            Sends an RPC to all clients. Notify the clients to start playing an emote animation.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.PlayerRPCs.ClientRPC(Eco.Gameplay.Players.Player,System.String,System.Object[])">
            <summary> Send Only to the Player's own client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.PlayerRPCs.ClientRPC(Eco.Gameplay.Players.Player,System.String,System.Action,System.Object[])">
            <summary> Send Only to the Player's own client.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.TimeLog.SecondsPlayedToday">
            <summary>Return the time played in the current day (not the last 24 hours, but in the last set of 24 hours since server start)</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.TimeUser">
            <summary>
            User which has Date when action can be applied
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Players.User">
            <summary>
            Partial class for <see cref="T:Eco.Gameplay.Players.User" /> for implementing the <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> interface
            </summary>
            <inheritdoc />
        </member>
        <member name="P:Eco.Gameplay.Players.User.Achievements">
            <summary>List of achievement names.</summary>
            <remarks>We serialize this even though it comes from the Achievement Manager so achievements can work on a given world even without that.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Players.User.TabSelected(System.String)">
            <summary> On client-site event used when the user select a tab</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.User.TryDamage(Eco.Shared.Networking.INetObject,System.Single)">
            <summary> Tries to make damage to user. If fails for some reason (in example User out of calories) then returns <c>false</c>. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.Migrate(Newtonsoft.Json.Linq.JObject)">
            <summary>Migration for the UserConfig from v.0 to v.1. We are using JObject for changes so we need to read, change and populate it once.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.TryGetValues(Newtonsoft.Json.Linq.JObject,System.String,Newtonsoft.Json.Linq.JToken@)">
            <summary>Returns original values collection for user list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.ConvertToStringList(Newtonsoft.Json.Linq.JObject,System.String)">
            <summary>Converts value for <paramref name="name" /> as list of strings. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserConfig.ConvertToTimeUserList(Newtonsoft.Json.Linq.JObject,System.String)">
            <summary>Converts value for <paramref name="name" /> as list of <see cref="T:Eco.Gameplay.Players.TimeUser" /> instances with very long ban time.</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.UserIdType">
            <summary>Defines all user identification types understood by Eco</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.UserManager">
            <summary>Singleton instance containing all the users in the game, logged in or not.</summary>
            <inheritdoc />
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.SetSpawnLocation(Eco.Shared.Math.Vector3i)">
            <summary>Sets the currently configured spawn location.</summary>
            <param name="loc">New spawn location to save to <seealso cref="P:Eco.Gameplay.Players.UserConfig.SpawnLocation" />.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.WithTempUserManager(System.Action)">
            <summary>Creates temp user management for time while action is running. Mainly for testing purposes.</summary>
            <param name="action">action to be executed with temp legislation.</param>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.GetOrRelocateSpawnPosition">
            <summary>Get or create a new spawn point.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.AuthorizeClientConnection(Eco.Shared.Authentication.LoginSession)">
            <summary>Checks if an incoming <seealso cref="T:Eco.Shared.Authentication.LoginSession" /> instance is authorized to connect.</summary>
            <param name="session"><seealso cref="T:Eco.Shared.Authentication.LoginSession" /> object to authorize</param>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.AddUserAuthorizer(Eco.Gameplay.Players.IUserAuthorizer)">
            <summary>Adds a <seealso cref="T:Eco.Gameplay.Players.IUserAuthorizer" /> instance to the UserManager's checklist</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserManager.RemoveUserAuthorizer(Eco.Gameplay.Players.IUserAuthorizer)">
            <summary>Removes a <seealso cref="T:Eco.Gameplay.Players.IUserAuthorizer" /> instance from the UserManager's checklist</summary>
        </member>
        <member name="T:Eco.Gameplay.Players.UserRecommendationHandler">
            <summary>Responsible for mailing recommendations to the user, listens to different events and based on it mails the owning user certain actions that can boost gameplay.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserRecommendationHandler.Initialize(Eco.Gameplay.Players.User)">
            <summary>Initializes the recommendation handler to the owning user.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.UserRecommendationHandler.CheckForOptimalHousingValue(Eco.Gameplay.Property.Deed)">
            <summary>Checks for optimal housing values and sends a mail to the owning user if there is a recommendation to change.</summary>
        </member>
        <member name="P:Eco.Gameplay.Players.UserUI.CurrentTab">
            <summary> Information of the last tab selected by the user </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.WorldMarkerManager.InternalEnableMarker(System.Boolean,System.Nullable{System.Guid})">
            <summary>Enable or disable markers. If the markerID is null, this function will run through all the markers</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.WorldMarkerManager.AddOrRemoveMakersFromDisabledList(System.Guid,System.Boolean)">
            <summary>If a marker is added to <see cref="P:Eco.Gameplay.Players.WorldMarkerManager.DisabledMarkers" />, it will be hidden. 
            That means if we want to disable a marker, just add it into to the list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Players.WorldMarkerUtils.MakeMarkerGlobal(Eco.Gameplay.Players.User,Eco.Gameplay.Players.WorldMarker)">
            <summary> Removes a marker from the user's list and adds it to the global list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Players.WorldMarkerUtils.MakeMarkerPersonal(Eco.Gameplay.Players.User,Eco.Gameplay.Players.WorldMarker)">
            <summary> Removes a marker from the global list and adds it to the user's list. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.Claim(Eco.Gameplay.Interactions.InteractionContext,Eco.Gameplay.Items.ItemStack,Eco.Gameplay.Property.Deed,System.Boolean)">
            <summary>Claim a plot of land</summary>
            <param name="context">The details of which to claim and what tool is getting used.</param> 
            <param name="claimStack">Optional specification of the claim papers being used.</param>
            <param name="forceDeed">Optional specification of the deed being claimed upon</param>
            <param name="usePlotCount">If set, we check the number of allowed plots on the deed instead of using papers at all.</param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.PositionNeighborsDeed(Eco.Gameplay.Property.Deed,Eco.Shared.Voxel.PlotPos)">
            <summary>Check if the given plot pos neighbors any plot on this deed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.RemovingPositionCausesSplit(Eco.Gameplay.Property.Deed,Eco.Shared.Voxel.PlotPos)">
            <summary>Checks if removing the given plot would split a deed.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.GetContiguousPartsWithAlterations(Eco.Gameplay.Property.Deed,System.Collections.Generic.List{Eco.Shared.Voxel.PlotPos},System.Collections.Generic.List{Eco.Shared.Voxel.PlotPos})">
            <summary>
            Gets all contiguous parts for deed after adding to it to Add plots and removing toRemove
            It's used to show dialog about changes (remove some deed will create N deeds by example) and to split deed to subdeeds if needed
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.ClaimWithConfirmation(Eco.Gameplay.Players.User,Eco.Gameplay.Property.Deed,Eco.Shared.Voxel.PlotPos,Eco.Shared.Localization.LocString,Eco.Gameplay.Items.ItemStack)">
            <summary> Claims a deed after user confirmation via ConfirmBox </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ClaimingUtils.GetClaimingPlotPos(Eco.Gameplay.Interactions.InteractionContext)">
            <summary>Returns claiming position in PLOT-SPACE.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.PropertyValue">
            <summary>The value of this deed, based on its type.</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.Deed.RelevantUsers">
            <summary> Residents and owners </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.CalcCenter">
            <summary>Calc the center, with respect to wrapped positions. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.ForceChangeOwners(Eco.Gameplay.Aliases.IAlias)">
            <summary>Changes owner of the deed without any checks.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Deed.TryChangeOwners(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Players.Player,Eco.Gameplay.Aliases.IAlias,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Perform related checks and pass the changing action through the action manager.</summary>
            <param name="pack">A game action pack to use.</param>
            <param name="changer">The one who will be 'Citizen' in all the checks and child actions.</param>
            <param name="newOwner">New owner of the deed.</param>
            <param name="transferAction">Is it needed to trigger a PropertyTransfer game action.</param>
            <param name="autoPerform">Is it needed to invoke pack.TryPerform() within this method.</param>
            <param name="okBox"></param>
            <param name="superAccess">There will be no check whether the changer has access to the property. Currently used for sales in the real estate desk.</param>
            <returns>Returns either result of CanChangeOwner chek or the result of the pack.TryPerform() invokation.</returns>
        </member>
        <member name="T:Eco.Gameplay.Property.IOwnableHandle">
            <summary> A reference to an object which can be owned by a deed.  The deed must be able
            to serialize this without duplicating the object. </summary>
        </member>
        <member name="T:Eco.Gameplay.Property.IDeedOwned">
            <summary>
            An object which can be owned by a deed.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyCommands.TargetOwner(Eco.Gameplay.Players.User,Eco.Shared.Networking.INetObject,Eco.Gameplay.Players.User)">
            <summary> own the target world object's deed, if it has credit component update it to avoid its closure. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyCommands.ChangeWorldObjectCreditOwnershipToTargetUser(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Players.User)">
            <summary> Update Credit component for the target user to give access directly to it. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyExtensions.PlotPosToOwnableHandles(System.Collections.Generic.IEnumerable{Eco.Shared.Voxel.PlotPos})">
            <summary> Converts provided plot pos vectors to OwnableHandles for deed operations.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyManager.RemoveDeed(Eco.Gameplay.Property.Deed,Eco.Gameplay.Players.User,System.Boolean,System.Boolean)">
            <summary>This removes the deed, when force parameter is true it forces the process avoiding prompts and laws.</summary>
        </member>
        <member name="M:Eco.Gameplay.Property.PropertyManager.MakePropertyClaimNotification(Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Builds final claim or unclaim notification</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlotHandle.PlotPos">
            <summary>NOTE: This is the position in WORLD SPACE, not plot grid</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlot.PlotPos">
            <summary>This is the position in PLOT-GRID, not world space</summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlot.CenterWorldPos">
            <summary>Shortcut for <code>Eco.World.World.GetTopGroundPos(this.PlotPos.CenterWorldPos)</code></summary>
        </member>
        <member name="P:Eco.Gameplay.Property.PropertyPlot.CornerWorldPos">
            <summary>Shortcut for <code>Eco.World.World.GetTopGroundPos(this.PlotPos.CornerWorldPos)</code></summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.TryDestroy(Eco.Gameplay.GameActions.GameActionPack,Eco.Shared.Items.ResidencyChangeReason)">
            <summary> Attempts to destroy the Residency objects. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.GetResidencyHouse(Eco.Gameplay.Players.User)">
            <summary> Returns any deed rented by user, which have any plot. </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.Residency.TryRemoveAllResidents(Eco.Gameplay.GameActions.GameActionPack,Eco.Gameplay.Property.Deed,Eco.Shared.Items.ResidencyChangeReason)">
            <summary> Adds actions to remove all residents, this doesn't process the pack </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.ResidencyExtensions.IsResidentType(Eco.Gameplay.Players.User,Eco.Shared.Items.SpecialResidents,System.Collections.Generic.IEnumerable{Eco.Gameplay.Property.Deed})">
            <summary>
            Check if a user belongs to a resident type (resident, renter, landlord, owner or invited)
            owner: someone who owns the property
            landlord: an owner + has non-owning residents
            resident: a person who is a resident on  the property
            renter: a person who is a resident and not an owner
            Owner or Landlord can't be renter or invitee
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Property.RoomChecker.CheckSolidAxis(Eco.Shared.Math.DirectionAxes,Eco.Shared.Math.Axis,System.Nullable{Eco.Shared.Math.DirectionAxis}@)">
            <summary>
            Checks if for specified axis both edges are solid.
            If one of edges isn't solid then it will save it in openDir.
            If openDir already set then it will return false, because only one dir may be opened.
            </summary>
            <param name="solidEdges"></param>
            <param name="axis"></param>
            <param name="openDir"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Property.RoomChecker.TryGetWindowAxis(Eco.Shared.Math.Vector3i,Eco.Shared.Math.Axis@)">
            <summary>
            Tries to get window axis for specified pos. It also checks if current pos is window.
            </summary>
            <param name="pos"></param>
            <param name="windowAxis"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.QueueRoomTest(Eco.Shared.Math.WrappedWorldPosition3i)">
            <summary> Queue up this position to be checked against all Rooms to determine if a Room has changed. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.QueueRoomValueRecalculation(System.Int32)">
            <summary> Queue up this RoomID to recalculate the relevant Room's RoomValue. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomData.GetEmptySpace(Eco.Shared.Math.Vector2i,Eco.Gameplay.Players.User)">
            <summary>Search for an empty space that fits a rectangle with a given size</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.Update(Eco.Core.Utils.ThreadSafeList{Eco.Gameplay.Rooms.Room},Eco.Core.Utils.ThreadSafeDictionary{Eco.Shared.Math.WrappedWorldPosition3i,Eco.Gameplay.Rooms.Room},System.Collections.Generic.IEnumerable{Eco.Shared.Math.WrappedWorldPosition3i},System.Collections.Generic.IEnumerable{Eco.Gameplay.Rooms.Room})">
            <summary> Update rooms to reflect the actual blocks. Adds to the passed list and sets up world objects.</summary>
            <param name="rooms">Full list of rooms, which is added to.</param>
            <param name="posToRooms">Mapping from positions to rooms</param>
            <param name="positions">Positions that we need to check for updates</param>
            <returns>The changes that occurred during the update: new, changed, and removed rooms.</returns>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.UpdateValueOnly(System.Collections.Generic.IEnumerable{Eco.Gameplay.Rooms.Room})">
            <summary> A more limited update that simply builds the room values, keeping the existing room stats on each room. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.UpdateRoomValuesAndFlagDeed(System.Collections.Generic.IEnumerable{Eco.Gameplay.Rooms.Room})">
            <summary> Updates the RoomValues of specific rooms and informs the associated Deed to update as necessary. </summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.ProcessChanges">
            <summary>Process all room changes (added, changed, removed).</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.AttachContainedWorldObjects(Eco.Gameplay.Rooms.Room)">
            <summary>Attaches all contained world objects to the room and removes them from detached.</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.DetachNotContainedWorldObjects">
            <summary>Detaches all not contained world objects from their rooms and moves them to GlobalRoom.</summary>
        </member>
        <member name="M:Eco.Gameplay.Rooms.RoomUpdater.TestChanges(System.Collections.Generic.IEnumerable{Eco.Shared.Math.WrappedWorldPosition3i})">
            <summary>
            Two step algorithm. First - recollect all possible positions, where it may modify somehow room. 
            After that - delete rooms in these positions and try create rooms there again (it won't create room where it was already added)
            </summary>
            <param name="positions"></param>
        </member>
        <member name="T:Eco.Gameplay.Settlements.CitizenRosterComponent">
            <summary>Main component for interacting with the list of citizens on a settlement.  Depending on the type of 
            settlement, it may allow you to change the citizens, or it may simply list the citizens in the children towns places.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.PersonalClaimStakeItem">
            <summary>A claim stake allows claiming plots contiguous with the stake.  A personal claim stake allows choosing which town settlement parents you.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementClaimStakeItem">
            <summary>A settement claim stake item is different than a personal one in that it is locked to a given settlement permanently.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakeItemBase`1">
            <summary>Defines common features for attempting to place claim stakes.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.PersonalClaimStakeObject">
            <summary>Personal claim stake objects can have a selectable parent town.</summary>       
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementClaimStakeObject">
            <summary>Settlement claim stake objects are linked to a single settlement.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ClaimStakeObject">
            <summary>The object that claims a plot and allows the claiming of more plots (using a surveryor tool) based on the number
            of claim-papers that are attached.  Plots must be contiguous to the claim stake.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.Settlement">
            <summary>A settlement defines 'influence' in the world upon which its government is applied and land can be claimed.
            It also maintains a list of citizens associated with the government, and polices for changing citizens.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.CurrentArticlesCached">
            <summary>All the active articles, from both the constituion and any amendments that modify that list.  Will contain invalid articles too.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.Settlement.HasValidConstitution">
            <summary> Returns false when where is currently no active and valid constitution. </summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.Settlement.Influences(Eco.Shared.Math.Vector2i)">
            <summary>Returns true if the settlement influences the given position.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementCitizenship">
            <summary>Tracks the citizens of a settlement using a Roster type, so new citizens can apply/be invited/accepted/etc.  Also
            tracks the number of claims and stakes that get spawned as population increases.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCitizenship.Initialize(Eco.Gameplay.Settlements.Settlement)">
            <summary>Setup a citizenship management for a settlement</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementCitizenship.UpdateCitizensCache">
            <summary>Event to update our citizens in any roster, as well as citizens in our children settlements.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementConfig.InfluenceRadii">
            <summary>The distance of influence that is exrted at each level of settlement, where the index is the settlement type.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementConfig.LandClaimsPerCitizenPastFirst">
            <summary>Landclaims made avaialble on the settlement marker at each level of settlement</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementConfig.ClaimStakesPerCitizenPastFirst">
            <summary>Claim stakes made avaialble on the settlement marker at each level of settlement</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementConfig.ClosestAllowedNeighborDistance">
            <summary>When founding a new settlement of the given type, it cant be closer than this distance to an existing settlement of the same type.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementConfig.BasePlotsOnClaimStake">
            <summary>The number of plots that a claim stake allows you to claim by default.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementConfig.HoursToResolvePropertyCrisis">
            <summary>If there are not enough citizens to support the claimed plots, a property crisis will happen after this amount of time.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.ISettlementAssociated">
            <summary>For items and other types that have an associated settlement. Allows using inventory restrictions that limit to a specific settlement (like claim stakes that can only
            hold claim papers from a specific settlement)</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementManager">
            <summary>Handles settlement creation and tracking, mapping their influence as well.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementManager.CreateSettlement(Eco.Gameplay.Objects.WorldObject,Eco.Shared.Items.SettlementType)">
            <summary>Create a brand new settlement and fill it in, and create extra parts like leaders and immigration.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementManager.PlayerPlotPosChanged(Eco.Gameplay.Players.Player,Eco.Shared.Math.Vector3i)">
            <summary>Update the status to show details of the settlement they're in when they move.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementManager.GetSettlementAtPos(Eco.Shared.Items.SettlementType,Eco.Shared.Math.Vector2i)">
            <summary>Return the settlement of the given type at the given position.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementManager.GetLowestLevelSettlementAtPos(Eco.Shared.Math.Vector2i)">
            <summary>Return the settlement of the lowest type (town before country before federation) at the given position.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementItemData">
            <summary>Persistent storage of the settlement that a marker item is linked to</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementMarkerItem`1">
            <summary>Base class for items that claim a settlement. Contains functions for defining how property can be claimed
            without overlapping with existing settlements or other plots.  Manages the display of that available land on the client.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementMarkerObject">
            <summary>Base class for objects that define a new settlement.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementParentage">
            <summary>Class that determines the parent settlement for another settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.Description">
            <summary>Describes the various children and land we claim with it.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementParentage.LineageName">
            <summary>Describe the parent's of this settlement.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.Reparent(Eco.Gameplay.Players.Player,Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Reparents a world object, which may also be a settlement, to a new parent.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementParentage.AssignChildren(Eco.Gameplay.Objects.WorldObject,Eco.Gameplay.Settlements.Settlement,Eco.Gameplay.Settlements.Settlement)">
            <summary>Helper to assign a parent obect and settlement to a parent settlement</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementParentComponent">
            <summary>A component for objects that can specify a settlement as their parent, like claim stakes, town halls, etc.  This is
            for objects that can choose from a variety of settlements to decaler their allegiance to, which will increase the settlement's 
            influence.</summary>
        </member>
        <member name="P:Eco.Gameplay.Settlements.SettlementParentComponent.SettlementOnThis">
            <summary>Shortcut to get the settlement this parent object defines (if its a townhall, say).  Will be null if its not defining a settlement (if it's a ClaimStake, say)</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementProperty">
            <summary>
            Component to Settlement that handles spawning/despawning stakes and claims as citizens come and go.  
            Handles property crises when not enough citizens for property.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.ClaimAndStakeInventoryChanged">
            <summary>Called by our holder object to let us know the inventory holding the claims and stakes has recently changed.  We only care if there's a property crisis, though,
            because there might be stakes/claims we need to despawn.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementProperty.BuildCrisisNotice(Eco.Shared.Localization.LocString)">
            <summary>Creates a crisis notice for the current time. 
            <paramref name="destinationDesc" />A description of where to return the stakes and claims.</summary>
        </member>
        <member name="M:Eco.Gameplay.Settlements.SettlementPropertyUtils.ShouldAllowClaim(Eco.Gameplay.Players.User,Eco.Shared.Voxel.PlotPos,Eco.Gameplay.Interactions.InteractResult@)">
            <summary>Look at all immigration policies on settlements at the given location and see if youre allowed to claim land here.</summary>
        </member>
        <member name="T:Eco.Gameplay.Settlements.SettlementSpawner">
            <summary>Spawns settlements with a variety of user decided options. Will become a source for a scenario spawner someday.</summary>
        </member>
        <member name="F:Eco.Gameplay.Settlements.SettlementUtils.TownDefaultSuffixes">
            <summary>These names will be appended when starting a town.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.Skill.InitializeSkills">
            <summary> Static skill initializer. </summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillCommands.SkillTypeByName(Eco.Gameplay.Players.User,System.String)">
            <summary>Find a skill type by any string</summary>
        </member>
        <member name="F:Eco.Gameplay.Skills.Skillset.UserSkillLevelChangedEvent">
            <summary> Raised when any skill of any user changes level </summary>
        </member>
        <member name="T:Eco.Gameplay.Skills.SkillTree">
            <summary>Helper class to send skill trees to client, skills are organized into trees based on reflection, with skills
                that have no required skills being root-level tree skills</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.DiscoveredBy">
            <summary>The user who Discovered the Skill.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.CachedSkillReqs">
            <summary>The requirements built from the tier.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.StaticSkill">
            <summary>The item in the global list of items representing the skill</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.ProfessionChildren">
            <summary>The children of the skill tree in profession/speciality basis.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.RequiredSkillLevelsMap">
            <summary>The children of this skill based on its SkillBook ingredients. (research basis), The key is the child skill tree and the value is the level of the parent skill at which it can unlock at.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.PlayerCountAtEachLevel">
            <summary>Level for professions means 'how many specialties under that profession'. For specialties, means the level of the specialty.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.LevelToRecipeUnlocked">
            <summary>The map of recipes unlocked at each level.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.TreeResearchRank">
            <summary>Specifies the node depth for the research tree.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.ResearchProject">
            <summary>The current active research project.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.IsUsingSkillBook">
            <summary> True if there are recipes available for the skill book. </summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.ResearchWorkOrders">
            <summary>Current active workorders for the skill book that tech this skill.</summary>
        </member>
        <member name="P:Eco.Gameplay.Skills.SkillTree.IngredientChildren">
            <summary>The collection of the skill tree children by its ingredients.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.BuildSkillTrees">
            <summary>Build the skill trees.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.SetUpIngredientChildren(System.Collections.Generic.IDictionary{System.Type,Eco.Gameplay.Skills.SkillTree})">
            <summary>Instantiate ingredient children for each skill tree. </summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.MakeNonTransitive(System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{Eco.Gameplay.Skills.RequiresSkillAttribute}})">
            <summary>Make the given dictionary of parents non transitive (i.e removes parents that repeat on a branch. </summary>
        </member>
        <member name="T:Eco.Gameplay.Skills.SkillTree.RequiresSkillAttributeEqualityComparer">
            <summary>Checks for Requires Skill Attribute Skill <see cref="T:System.Type" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.CheckForResearchAttributes(System.Type)">
            <summary>Get Required skills to obtain skillbooks for the given skill.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetRequiredSkillForItem(System.Type)">
            <summary>Get Required skills to obtain skillbooks for the given skill.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.BuildTreeList(System.Type,System.Collections.Generic.List{Eco.Gameplay.Skills.SkillTree},Eco.Gameplay.Items.SkillBook[],Eco.Core.Utils.ThreadSafeDictionary{System.Type,Eco.Gameplay.Skills.SkillTree},Eco.Gameplay.Skills.SkillsLookUp)">
            <summary>Iterates through the given set of data to build SkillTrees to the given SkillsLookup.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetDependentSkillsRecursive(System.Type,System.Collections.Generic.Dictionary{System.Type,Eco.Gameplay.Skills.RequiresSkillAttribute})">
            <summary>Gets the skill Types that depend on the given skill Type, directly or undirectly.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetDependentSkills(System.Type,System.Collections.Generic.Dictionary{System.Type,Eco.Gameplay.Skills.RequiresSkillAttribute})">
            <summary>Gets the skill Types that directly depend on the given skill Type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.SkillTree.GetRequiredSkillsMap(System.Type,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{Eco.Gameplay.Skills.RequiresSkillAttribute}})">
            <summary>Get the skill type and at which level that skill depend on the given skill type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Skills.Talent.OnLearned(Eco.Gameplay.Players.User)">
            <summary>
            This method called when talent just learned to apply modifications to existing objects (like reduce requirements, update statuses etc).
            </summary>
            <param name="user"></param>
        </member>
        <member name="M:Eco.Gameplay.Skills.Talent.RegisterTalent(Eco.Gameplay.Players.User)">
            <summary>
            This method called every time when talent added to user either when learned or deserialized.
            Use this method for callbacks registration.
            </summary>
            <param name="user"></param>
        </member>
        <member name="T:Eco.Gameplay.Systems.Chat.IChatClient">
            <summary>
            <para>
            The interface that something needs to implement in order to perform chat commands.
            Used by User and RCON currently. Chat commands can accept either a <seealso cref="T:Eco.Gameplay.Players.User" /> or an <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" />
            </para>
            
            <para>
            Difference between using <seealso cref="T:Eco.Gameplay.Players.User" /> vs. <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> as the first argument include:
            <list type="bullet">
            <item><description>If they accept a <seealso cref="T:Eco.Gameplay.Players.User" />, they are allowed to have full access to that <seealso cref="T:Eco.Gameplay.Players.User" />'s interface, but those chat commands cant be called by headless clients like RCON</description></item>
            <item><description>If they accept an <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" />, they have a limited set of properties (below) which they can access from the chatClient, but both Users in game and headless clients such as RCON can call these functions.</description></item>
            </list>
            </para>
            
            <para>Generally if you only need to issue return displays and make modifications to the world, you should make the chat command accept <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" />, so headless clients like RCON can call it.</para>
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Chat.IChatClient.Name">
            <summary> Represents the display name of this <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Chat.IChatClient.MarkedUpName">
            <summary> Represents the markup display name of this <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Chat.IChatClient.ImplementationName">
            <summary> Represents the internal name of this implementation. Used in things suchas error messages </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.GetChatAuthLevel">
            <summary>
            Returns this Invoker's <seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel" /> value for use in command permission checks
            </summary>
            <returns><seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel" /> if the Invoker</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.TempServerMessage(Eco.Shared.Localization.LocString,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle)">
            <summary>
            Sends a message to the command invoker that is intended to be temporary. This method may not be supported by all command invokers. If the method is not 
            supported these messages should be routed to a normal <seealso cref="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLocStr(System.String,Eco.Shared.Services.NotificationStyle)" /> message call.
            </summary>
            <param name="message">Message to send to the invoker from a chat command</param>
            <param name="category"><seealso cref="T:Eco.Shared.Services.NotificationCategory" />The chat tags associated with this message</param>
            <param name="style"><seealso cref="T:Eco.Shared.Services.NotificationStyle" /> of the message to be sent</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLoc(System.FormattableString,Eco.Shared.Services.NotificationStyle)">
            <summary>
            Sends a generic message to the command invoker from a chat command using the specified <seealso cref="T:Eco.Shared.Services.NotificationStyle" /> style to determine how to display it for
            invokers that support it.
            </summary>
            <param name="msg">Message to send to the invoker from a chat command</param>
            <param name="style"><seealso cref="T:Eco.Shared.Services.NotificationStyle" /> of the message to be sent</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.Msg(Eco.Shared.Localization.LocString,Eco.Shared.Services.NotificationStyle)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLoc(System.FormattableString,Eco.Shared.Services.NotificationStyle)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLocStr(System.String,Eco.Shared.Services.NotificationStyle)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Chat.IChatClient.MsgLoc(System.FormattableString,Eco.Shared.Services.NotificationStyle)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.ErrorLoc(System.FormattableString)">
            <summary>
            Sends a error message to the command invoker from a chat command
            </summary>
            <param name="msg">Error message to send to the invoker from a chat command</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.Error(Eco.Shared.Localization.LocString)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Chat.IChatClient.ErrorLoc(System.FormattableString)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Chat.IChatClient.ErrorLocStr(System.String)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Chat.IChatClient.ErrorLoc(System.FormattableString)" />
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel">
            <summary>Channels are managed via <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager" />. Channel has a Manager/User permission set using Aliases, that allows creating rich and contextual communication hubs in game.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.GetLinkableName">
            <summary>Define a string that will be parsed as a link for the Channel, so we do not overlap custom names of channels and simple words or names of other objects.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.OnLinkClicked(Eco.Gameplay.Systems.Tooltip.TooltipContext,Eco.Gameplay.Systems.Tooltip.TooltipClickContext)">
            <summary>Set this channel as a receiver (change output tag) with clicking on it's name in the Chat Log.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.LinkClickedTooltipContent(Eco.Gameplay.Systems.Tooltip.TooltipContext)">
            <summary>Make a click description in a tooltip.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.SetChannelName(Eco.Gameplay.Players.Player,System.String)">
            <summary>Custom RPC needed for draft dialog title edit: cannot use SetName because it will cause Registrar entry rename - we don't want it while in draft mode</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel.EditChannel(Eco.Gameplay.Players.Player)">
            <summary>Edit request by player, needed for Auto views setup</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager">
            <summary>Handles all global concerns of Channels: creation, editing, removal. Also initializes special/system channels. Is synced to each individual client via <see cref="P:Eco.Gameplay.Systems.GlobalData.Channels" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.CreateChannel(Eco.Gameplay.Players.Player)">
            <summary>Opens editor UI with a default (public) channel draft, that will be active and usable only after saving.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.EditChannel(Eco.Gameplay.Players.Player,Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>Opens editor UI for the given channel.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.RemoveChannel(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>When player requests to remove channel (will check permissions and popup confirm dialog)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.RemoveChannel(Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>Remove channel and all associated chat messages</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.Get(Eco.Gameplay.Systems.Messaging.Chat.Channels.SpecialChannel)">
            <summary>Retrieves a special channel given it's type.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Channels.ChannelManager.MakeDefaultChannel(System.String,Eco.Gameplay.Players.Player)">
            <summary>Sets up a default channel that can be used by everyone.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatDataPartition">
            <summary>Persistent Chat Data. May be used as stand-alone chat messages storage or as a partition of <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" /> (as used in <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.ChatManager" />).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatDataPartition.RemoveAll(System.Predicate{Eco.Gameplay.Systems.Messaging.Chat.ChatMessage})">
            <inheritdoc cref="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.AddCommandHandler(System.Type)">
            <summary>Adds handler type. May be used for types which not auto-discovered by reflection (i.e. when some commands only available under specific conditions).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.ExecuteCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <summary>
            Execute a command string directly, from a <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> rather than a <seealso cref="T:Eco.Gameplay.Players.User" />. This allows only a subset of chat commands
            (those that accept <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instead of User as their first property). Does not require the beginning forward slash '/')
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.ExecuteCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.ExecuteCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.RemoveChannelReferencesFromChat(Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel)">
            <summary>
            Remove a specific channel, that was deleted from the game, from all the tabs that have it in their "Chat Sources"(the list of all the channels that can be displayed in that tab)
            and all associated chat messages
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.RemoveMessages(System.Predicate{Eco.Gameplay.Systems.Messaging.Chat.ChatMessage})">
            <summary>Removes all messages matching <paramref name="predicate" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatManager.TryResetChatSettings">
            <summary>Reset chat settings of all users to use the default. Mostly used for testing and playtest.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatMessage">
            <summary> Used in server/client side and for storage.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatMessage.ToBson(Eco.Shared.Networking.INetClient)">
            <summary>Not IBSONSerializable because takes INetClient arg to pack controllers</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.SanitizeChatInput(System.String)">
            <summary>Given a raw chat message, strips it from size tags and control characters.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.ResolveReceiver(System.String,System.String@)">
            <summary>Given a raw chat message, attempt to extract receiver and actual message part.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.FindChannelInChatMessage(System.String)">
            <summary>Given a raw chat message, looks up the first part before space to attempt to resolve a <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Channels.Channel" />.</summary>
            <remarks>Used exclusively by <see cref="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.ResolveReceiver(System.String,System.String@)" />.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatParsingUtils.FindUserInChatMessage(System.String)">
            <summary>Will take the longest name that can be found at the beginning of a text line.
            E.g. Text: @test client 1 [some more text] we will take @test client 1 as a user chat tag, and @test will be skipped.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings">
            <summary>
            Client's chat settings are stored on the server within this class (instead of UserPrefs)
            Client can reorder tabs but can't add or remove tabs (using ChatManager's RPCs instead)
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.TryAddTab(Eco.Shared.Networking.INetObject)">
            <summary>Called when client requests adding via AddRPC call from ViewUIContainer - no traditional add allowed, instead draft dialog will be shows</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.AddTab(Eco.Gameplay.Players.Player,System.Int32)">
            <summary>Requests client to open draft chat tab editor, tab will be added only if pressed Apply button</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.EditTab(Eco.Gameplay.Players.Player,System.Int32)">
            <summary>Requests client to open draft chat tab editor.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.HideTab(Eco.Gameplay.Players.Player,Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsBase)">
            <summary>Requests client to move the tab to the Hidden Tabs list.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.InsertOrEditTab(Eco.Gameplay.Players.Player,System.Int32,System.Boolean)">
            <summary>Requests client to open draft chat tab editor. Can be new tab or existing tab</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.InsertTabAndSetActive(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsBase,System.Int32,System.Boolean,System.Boolean)">
            <param name="activateTab">Should we set the tab as active ?</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.OnRemove(Eco.Shared.Networking.INetObject,System.Object)">
            <summary>If the tab removed was not the last one (generally there is always at least one tab), make the next tab active.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.EnsureTabExistsForReceiver(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver,System.Boolean,System.Boolean)">
            <summary>Ensure we have a tab for IChatReceiver and if not - try to create this tab</summary>
            <param name="activateTab">Should we set the tab as active ?</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatSettings.CreateNotificationTab(Eco.Gameplay.Players.Player,Eco.Shared.Services.NotificationCategory)">
            <summary>Create a chat tab for notifications from  <param name="category">category</param></summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsBase">
            <summary>
            Chat tab represents current chat 'window' and user always has at least on active tab. Tab settings tells chat which message are visible within that tab.
            Settings for chat tabs are stored on server in ChatManager. Name should not be empty and can have collisions with other tabs. Tab names are not localized.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsCommon">
            <summary>
            Represent the common tabs that are created manually by the player (or in some cases automatically) and that can be modified.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsCommon.EditNotificationSettings(Eco.Gameplay.Players.Player)">
            <summary>Opens multi-selector popup on client. This is needed to allow pick from general picker without using registrars</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsCommon.Valid">
            <summary>Choose whether to make the submit button interactable or not depending on whether there's at least one channel or notification source.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.ChatTabSettingsWhisper">
            <summary>Represent the private tabs that are created automatically when the whisperMode is active and the player send or receive a message from another player. Player cannot modify this tab.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.AdminCommands.MakeCutWall(Eco.Shared.Math.Vector3i,Eco.Gameplay.Players.User,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>Make a wall that cuts into the landscape at the given height</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand">
            <summary> Class holding information about chat command (built from <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" /> and <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatSubCommandAttribute" />). </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.FullName">
            <summary> Returns fully qualified command name (including parent name if it is sub command). </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.Matches(System.String)">
            <summary> Checks if <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> matches searchString. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.WithLanguage(Eco.Shared.Localization.SupportedLanguage)">
            <summary> Returns <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> localized for <paramref name="language" />. It will only correctly work if original command is in English locale. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.LocalizeCommandName(System.String,Eco.Shared.Localization.SupportedLanguage)">
            <summary> Localizes command name. It applies some transformations to ensure command name is valid and properly formatted. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand.CommandRequiresUser">
            <summary>Checks if this command requires a user object to be executed.</summary>
            <returns>True if the command requres a user</returns>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.IChatCommandHandler">
            <summary>
            Interface used to enable chat commands. Derive from this interface to
            make any functions in the class with the ChatCommand attribute
            available to the chat manager.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService">
            <summary> Service responsible for <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> registration and processing.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetAllCommands">
            <summary> Returns all registered commands (including sub commands). </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetAllHeadlessCommands">
            <summary> Returns all registered commands (including sub commands) that can be used by a headless <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> such as RCON. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryParseAndIdentifyCommand(System.String@,Eco.Shared.Localization.SupportedLanguage,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand@)">
            <summary>
            Tries to parse <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> from <paramref name="unparsed" /> string.
            It has following outputs:
            <list type="bullet">
            <item>if string is empty then <paramref name="chatCommand" /> is <c>null</c> and failed without message;</item>
            <item>if no matching command then <paramref name="chatCommand" /> is <c>null</c> and failed with message about unknown command, command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command without sub commands then <paramref name="chatCommand" /> set to command and result is succeed, command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command with sub commands and sub command name is empty then <paramref name="chatCommand" /> set to command and result is failed without message, command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command with sub commands and no matching sub command then <paramref name="chatCommand" /> set to command and result is failed with message about unknown sub command, command name and sub command name removed from <paramref name="unparsed" />;</item>
            <item>if matching command with sub commands and matching sub command then <paramref name="chatCommand" /> set to sub command and result is succeed, command name and sub command name removed from <paramref name="unparsed" />;</item>
            </list>
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryGetCommand(Eco.Shared.Localization.SupportedLanguage,System.String,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand@)">
            <summary>Tries to get <paramref name="command" /> either by english <paramref name="name" /> or by localized name. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryParseCommandName(System.String@,System.String@)">
            <summary>
            Tries to parse <paramref name="commandName" /> from <paramref name="unparsed" />. If succeed then it removes <paramref name="commandName" /> from <paramref name="unparsed" /> and returns <c>true</c>.
            Returns <c>false</c> otherwise and <paramref name="unparsed" /> stays untouched.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.HandleCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryInvokeCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject,System.Threading.Tasks.Task@)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.HandleCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryInvokeCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject,System.Threading.Tasks.Task@)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryInvokeCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject,System.Threading.Tasks.Task@)">
            <summary>Tries to handle command from <paramref name="text" /> (it should start with '/'). If it isn't a valid command string then it returns false. </summary>
            <param name="chatClient">Chat client used to execute the command</param>
            <param name="text">Full command string to execute</param>
            <param name="language">Language to execute the command under</param>
            <returns>True if a valid command starting with a forward slash was supplied.</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.CanRunCommand(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand)">
            <summary>Checks if a <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> can run the requested <seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" />.</summary>
            <param name="chatClient"><seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance to check.</param>
            <param name="command"><seealso cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> instance to check if the <paramref name="chatClient" /> can run.</param>
            <returns>True if the <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instance can run the command.</returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetCommandMapping(Eco.Shared.Localization.SupportedLanguage)">
            <summary> Returns command mapping for <paramref name="language" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.InvokeCommand(Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand,System.String,Eco.Gameplay.Systems.Chat.IChatClient,Eco.Shared.Localization.SupportedLanguage,Eco.Shared.Networking.INetObject)">
            <summary> Invokes <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> with unparsed <paramref name="args" /> string. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ShowHelp(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand)">
            <summary> Shows help for <paramref name="command" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ShowHelpByQuery(Eco.Gameplay.Systems.Chat.IChatClient,Eco.Shared.Localization.SupportedLanguage,System.String,System.Boolean)">
            <summary>
            Shows help for <paramref name="query" />. It depends on <paramref name="query" /> content:
            <list type="bullet">
            <item>`command[ subCommand]` - will show help for command/sub command/shortcut</item>
            <item>`command unknownSubCommand` - will show help for command</item>
            <item>`unknownCommand` - show all commands matching `unknownCommand` substring</item>
            <item>`` - will show all commands</item>
            </list>
            If <paramref name="full" /> is set then will expand sub commands for all commands.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetFilteredCommands(Eco.Shared.Localization.SupportedLanguage,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel,System.Boolean,System.Boolean,System.String)">
            <summary> Returns commands matching filter parameters. </summary>
            <param name="language"></param>
            <param name="authLevel">Will only return commands with auth level less or equal to this level.</param>
            <param name="expandSubCommands">If set then will expand sub commands for matched commands.</param>
            <param name="headless">If set to false then the commands will be filtered to only those that can be invoked by <seealso cref="T:Eco.Gameplay.Systems.Chat.IChatClient" /> instances that are not a <seealso cref="T:Eco.Gameplay.Players.User" /></param>
            <param name="searchString">Optional filter string for command names.</param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.SendHelpReport(Eco.Gameplay.Systems.Chat.IChatClient,System.Text.StringBuilder)">
            <summary> Sends help in <paramref name="sb" /> to the <paramref name="chatClient" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandsSummary(System.Text.StringBuilder,System.Collections.Generic.IEnumerable{Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand},System.Boolean)">
            <summary> Appends only summary for <paramref name="commands" />. If <paramref name="nameOnly" /> set then will use command name only instead of fully qualified name with '/' prefix. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandUsage(System.Text.StringBuilder,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand)">
            <summary> Appends command usage info including all parameters with types and hints. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandHelp(System.Text.StringBuilder,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatAuthorizationLevel,System.Boolean)">
            <summary>
            Appends <paramref name="command" /> help (only if it allowed by <paramref name="authLevel" />). Output will depend on command type.
            If it is root command then it will show command summary and all sub commands. Otherwise it will show usage for the command.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AppendCommandSummary(System.Text.StringBuilder,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand,System.Boolean)">
            <summary> Appends <paramref name="command" /> summary (name with help text). It <paramref name="nameOnly" /> set then will use command name instead of fully qualified name with '/' prefix. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GroupByAuthLevel(System.Collections.Generic.IEnumerable{Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand})">
            <summary> Groups commands by their auth level and sorts by auth level name. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ParamFormat(System.String)">
            <summary> Formats parameter with own style. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.GetPrettyCommandParameterTypeName(System.Type)">
            <summary> Returns "pretty" name for parameter type. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.LogAdminCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String)">
            <summary> Adds info about admin command executed by <paramref name="chatClient" /> to special admin commands log. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.TryMakeChatCommand(System.Reflection.MethodInfo,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand@)">
            <summary>Tries to make <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand" /> for <paramref name="method" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AddTypeCommands(System.Type,System.Collections.Generic.Dictionary{System.String,Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand},System.Collections.Generic.List{Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommand})">
            <summary>Scans <paramref name="handlerType" /> for methods which may be used as chat commands and adds them to collections.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AddCommandHandlers(System.Collections.Generic.IEnumerable{System.Type})">
            <summary> Collects all chat commands for <paramref name="handlerTypes" /> and registers them in <see cref="F:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.commandsByLanguage" /> dictionary for English language.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.AddHandlersByReflection">
            <summary> Collects all chat commands by reflection and registers them in <see cref="F:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.commandsByLanguage" /> dictionary for English language.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ValidParameterType(System.Type)">
            <summary> Checks if <paramref name="type" /> is valid type for chat command parameter. </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.CheckCommandsAuthLevel">
            <summary> Tell with warning if any command has AuthLevel lower than any of it's subcommands. That can lead to the wrong /help for commands.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandService.ReplaceCommandProcessor">
            <summary> Checks if a mod contains a custom method for handling command processing logic. Only accepts the first method that meets the requirements. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.MessagingCommands">
            <summary>Messaging commands related to chat itself, also mail and notification commands<p /><c>[UsedImplicitly]</c></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.RegistrarChatCommands.GetReg(Eco.Gameplay.Players.User,System.String,System.String)">
            <summary> Gets the named Registrar, sending an error response to the user if it could not be found. </summary>
            <param name="user"></param>
            <param name="name"></param>
            <param name="exampleDescription"> A textual example showing the format this command should take. </param>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.Commands.RegistrarChatCommands.GetEntry(Eco.Gameplay.Players.User,System.String,System.String,System.String)">
            <summary>
             Gets the named Entry (object) specified by the user, sending an error response to the user if it could not be found. 
            </summary>
            <param name="user"></param>
            <param name="exampleDescription">A textual example showing the format this command should take. </param>
            <param name="partialTypeName"></param>
            <param name="partialObjectNameOrId"></param>
            <returns></returns>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.Send(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver,System.String)">
            <summary></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.AddCommandHandler(System.Type)">
            <summary>Adds command handler type which should contains one or more methods with <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatCommandAttribute" /> or <see cref="T:Eco.Gameplay.Systems.Messaging.Chat.Commands.ChatSubCommandAttribute" />. This method should be called before ChatManager initialization finished.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.GetAllCommands">
            <summary>Get list of all chat commands (from all IChatCommandHandler classes)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.SetChatReceiver(Eco.Gameplay.Players.Player,Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver,System.Boolean)">
            <summary>Set client's current chat receiver (user or channel) (instead previous OutputTag), it also can include activation of the chat log</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.ExecuteCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <summary>Executes command (starting from slash), commands are defined in IChatCommandHandler classes</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.ExecuteCommandAsync(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)">
            <inheritdoc cref="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.ExecuteCommand(Eco.Gameplay.Systems.Chat.IChatClient,System.String,Eco.Shared.Localization.SupportedLanguage)" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Chat.IChatManager.GetSettingsForUser(Eco.Gameplay.Players.User)">
            <summary>Get chat settings and chat tabs for user, which are stored on server</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver">
            <summary>Chat can only be sent to entities tagged as IChatReceiver.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver.ChatRecipients">
            <summary>The underlying users that the receiving target represents.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver.ChatTag">
            <summary>Chat tag this chat receiver associated with.</summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.Messaging.Chat.IChatReceiver.MarkedUpChatTag">
            <summary>Marked up name used to display in chat message</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.NotificationMessageSource">
            <summary>
            Notification sources are managed in chat manager.
            They are read only channels that allow the player to choose what notification category to see or to show whispers in tab.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Chat.NotificationSource">
            <summary>
            This class is specific for notifications, it derives from NotificationMessageSource and adds NotificationCategory
            it allows to choose NotificationCategories in ChatTabSettings to show in chat tab
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications.AddAggregatedMessage(Eco.Gameplay.Players.User,System.String,System.Object,System.Double,System.Func{Eco.Gameplay.Players.User,System.Collections.Generic.IEnumerable{System.Object},Eco.Shared.Localization.LocString})">
            <summary>Begin an aggregated message that appends the passed data to the list, updates the time of send, and assigns
            the instructions to how to build the final data.  The notification will be identified as a key of user+handle string.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.AggregatedNotifications.GetAndClearReadyAggegatedMessages">
            <summary>Get any aggregated messages from the queue, and clear them from the list</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.BroadcastNotification">
            <summary>Broadcast notification to all users.</summary>
            <inheritdoc />
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.DirectNotification">
            <summary>Direct notification to one or more users.</summary>
            <inheritdoc />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.INotificationManager.Send(System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},Eco.Shared.Services.NotificationCategory,Eco.Shared.Localization.LocString,Eco.Shared.Services.NotificationStyle,System.Collections.Generic.IEnumerable{Eco.Gameplay.Players.User},System.Boolean)">
            <summary>
            Sends <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification" /> to users from <paramref name="to" /> enumerable. If <paramref name="to" /> is <c>null</c> then sends to all users, but if <paramref name="to" /> is empty then doesn't send notification to any user.
            This way you may distinguish between empty user set (i.e. from Demographic) and broadcast message.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification">
            <summary>Notification for use in server side and for storage. Client side uses manually created NotificationView representation</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.Notification.GetReceivers">
            <summary>Returns all receivers as enumerable for the <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.Notification.GetOnlineReceivers">
            <summary>Returns only online receivers as enumerable for the <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.Notification" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.Notification.HasReceiver(Eco.Gameplay.Players.User)">
            <summary>Checks if the notification has <paramref name="receiver" />.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Messaging.Notifications.NotificationDataPartition">
            <summary>Persistent Notification Data. May be used as stand-alone notification storage or as a partition of <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" /> (as used in <see cref="T:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager" />).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationDataPartition.RemoveAll(System.Predicate{Eco.Gameplay.Systems.Messaging.Notifications.Notification})">
            <inheritdoc cref="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})" />
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.TemporaryServerMessageToPlayer(Eco.Shared.Localization.LocString,Eco.Gameplay.Players.User,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle)">
            <summary> Send chat message to player, it's temporary won't be stored on server storage </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.ServerMessageToPlayer(Eco.Shared.Localization.LocString,Eco.Gameplay.Players.User,Eco.Shared.Services.NotificationCategory,Eco.Shared.Services.NotificationStyle,System.Boolean)">
            <summary> Send chat message to player </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.ProcessNotification(Eco.Gameplay.Systems.Messaging.Notifications.Notification,System.Boolean)">
            <summary>Process notification (displays to users and adds to notification log).</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.SendInstantNotification(Eco.Gameplay.Players.User,Eco.Shared.Localization.LocString,Eco.Shared.Services.InstantNotificationPosition)">
            <summary>Send RPC with <param name="notificationMessage"></param> notification message and <param name="position"></param> position to <param name="user"></param>user</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Messaging.Notifications.NotificationManager.SendImportantMessage(Eco.Gameplay.Systems.Messaging.Notifications.Notification,System.Boolean)">
            <summary> Create a new wrapped mail for users list, because we dont save references to mail messages (perhaps we change this later to save space on serializing duplicated mail) </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.NewTooltipAttribute">
            <summary>Marks a method, property, or field as a 'TooltipPart'.  Tooltip parts will be composed to form the tooltip for a type.
            See tootlip.md for the full picture.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.NewTooltipChildrenAttribute">
            <summary>
            Use on properties returning one or more objects of type that implements IController interface. 
            Objects returned by this member will have their tooltip members included along with 
            this object's tooltip.  Adding a <see cref="F:Eco.Gameplay.Systems.NewTooltip.NewTooltipChildrenAttribute.ExcludeCategories" /> as a parameter
            to the attribute will filter tooltips of that type from the child(ren) for this object's tooltip.
            </summary>
        </member>
        <member name="P:Eco.Gameplay.Systems.NewTooltip.TooltipCacheErrorDetection.AllCache">
            <summary>Go through all parts in the cache. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.EconomyTooltipLibrary">
            <summary>Tooltips related to the economy. This class both sets up the needed subdscription that will 'dirty' the tooltip as needed, and defines the actual tooltip parts related to it.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary">
            <summary>Tooltip library for all tooltips related to skills and their levels</summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary.skillUnlocksTooltips">
            <summary>Cached data for <see cref="M:Eco.Gameplay.Systems.NewTooltip.TooltipLibraryFiles.SkillTooltipLibrary.UnlocksDescription(Eco.Gameplay.Skills.Skill)" /> tooltip part</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.AddClientTypes``1(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{``0}},System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{``0}})">
            <summary>Adds only client types (having associated view) to <paramref name="clientTypeToParts" /> filtered from <paramref name="typeToParts" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipManagerServer.ClearCache">
            <summary>Removes all cached data in ourselves and children support classes.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.MakeRef(System.Int32,System.Int32)">
            <summary>Create a reference to this part, omitting the controller and user ID if we dont care about them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.GetText(System.Type,Eco.Core.Controller.IController,Eco.Shared.Items.TooltipOrigin,Eco.Gameplay.Players.User)">
            <summary>Main cache querying function. Get thes type + obj + origin + user and returns the cache for that combo, or builds it if it doesnt exist</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.ClearCache">
            <summary>Clear the cache of everything</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipPart.ClearCache(System.Int32)">
            <summary> Clear cache for given object</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.Subscribe(Eco.Gameplay.Players.User,Eco.Gameplay.Systems.NewTooltip.TooltipPart,Eco.Core.Controller.IController)">
            <summary>Marks a user as having recevied the tooltip part, so we know to inform them if it gets invalidated.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForAll(System.Type,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users and all instances of <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForUser(Eco.Gameplay.Players.User,System.Type,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" /> for all instances of <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkPartRefsDirty(Eco.Gameplay.Players.User,System.Collections.Generic.HashSet{Eco.Shared.Items.TooltipPartRef},System.Type,System.String)">
            <summary>Marks every tooltip part referenced by <see cref="T:Eco.Shared.Items.TooltipPartRef" /> in <paramref name="partRefs" /> that matches <paramref name="tooltipName" /> and <paramref name="baseType" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirtyForInstance(Eco.Core.Controller.IController,System.String)">
            <summary>Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for all users, but only for <paramref name="controller" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,Eco.Core.Controller.IController,System.String)">
            <summary> Marks a tooltip part with name matching <paramref name="tooltipName" /> as dirty for <paramref name="user" />, but only for <paramref name="controller" /> </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.MarkDirty(Eco.Gameplay.Players.User,Eco.Core.Controller.IController,Eco.Gameplay.Systems.NewTooltip.TooltipPart)">
            <summary>Marks <paramref name="part" /> as dirty for <paramref name="user" />, but only for <paramref name="controller" /></summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.ApplyDirtyTooltips">
            <summary>Go through all the dirty tooltips and tell whoever subscribes to each one that they're gonna need to refresh next time they need it.
            Also clear the server cache for these dirty tooltips.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.ClearCacheForUser(Eco.Gameplay.Players.User)">
            <summary>Clears the record of parts that this user is subscribed to. Since we dont store user-specific data on the server-side cache, we
            dont need to remove any cached data otherwise.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubscriptions.ClearCache">
            <summary>Clear the cache and list of dirty things.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipSubExtensions.GetPart(Eco.Shared.Items.TooltipPartRef)">
            <summary>Get the tooltip part this ref struct refers to.</summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.NewTooltip.AffectsTooltipAttribute">
            <summary>This attribute makes marking tooltip parts 'dirty' easier.  To use it, tag a property and pass in the name of the tooltip
            part that should be marked dirty when that property changes. The containing class must derive INotifyPropertyChanged, which is
            what causes Fody to inject the 'on changed' handling code.  Youll also need to assign the PropertyChangedEventHandler to 
            'TooltipUtils.Changed', where it does the check (this also does the regular controller notifications too)</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipUtils.Changed(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>For use with INotifyPropertyChanged, set as the PropertyChanged event handler. Then it will detect changed tooltips and notify the tooltip server.</summary>
            <remarks>It will also call <see cref="M:Eco.Core.Controller.ControllerExtensions.Changed``1(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /></remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.NewTooltip.TooltipUtils.SimpleChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>For use with INotifyPropertyChanged, set as the PropertyChanged event handler. Then it will detect changed tooltips and notify the tooltip server.</summary>
            <remarks>Unlike <see cref="M:Eco.Gameplay.Systems.NewTooltip.TooltipUtils.Changed(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> this method won't call <see cref="M:Eco.Core.Controller.ControllerExtensions.Changed``1(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /></remarks>
        </member>
        <member name="T:Eco.Gameplay.Systems.IRegistrarManager">
            <summary>
            Provides features for untyped registrar management:
            - Maintains a set of 'special' entries that are always there.
            You should prefer to use parameterized types interface instead for implementation, but this interface may be used for type-unaware processing.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.SleepManager.WakePlayerUp(Eco.Gameplay.Players.Player)">
            <summary>If the bed that player's sleeping on is destroyed, we need to wake the player up</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.ObjectFinderUtils.ToWordRegex(System.String)">
            <summary>
            Create a regex that searches for an occurrence of 'regex' that is not adjacent to word characters
            on either side (if regex="axe", match "axe" or "axe?" but not "axer").
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.ObjectFinderUtils.ToWordRegex(System.Linq.IOrderedEnumerable{System.String})">
            <summary>
            Create a regex that searches for an occurrence of any word in 'words' that is not adjacent to word characters
            on either side (if regex="axe", match "axe" or "axe?" but not "axer").
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.RegistrarFinder.Add(Eco.Core.Systems.IHasID)">
            <summary> Adds new <see cref="T:Eco.Core.Systems.IHasID" /> instance to <see cref="T:Eco.Gameplay.Systems.TextLinks.RegistrarFinder" />. </summary>
        </member>
        <member name="F:Eco.Gameplay.Systems.TextLinks.ReferenceIDTranslator.ObsoleteLinksResolvers">
            <summary>
            AB: Mapping for obsolete links. It is a hack and proper way is to not use typename in links to avoid problems like that when after refactoring links are broken.
            Migrating links is a complex task, because they may appear anywhere. There possibility to scan every string for links (very slow) or mark every field which potentially may contain links and scan only these on migration (still may be very slow depending on number of links).
            So for now it is just a mapping of obsolete links to link resolvers. Because we can't guarantee that server save won't be migrated to newest versions we can't ever remove this mapping
            without making old links broken.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.TextLinks.TextLinkButton">
            <summary> Clickable UI link that can be used in tooltips. For a demo see <see cref="M:Eco.Gameplay.Items.WorkOrder.OwnershipTooltip(Eco.Gameplay.Players.Player)" /> or <see cref="T:Eco.Gameplay.Items.ItemPersistentData" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TextLinkManager.OnButtonClicked(System.String,System.String,Eco.Shared.Serialization.BSONObject,Eco.Shared.Networking.INetClient)">
            <summary>Handles button link presses, invokes the give rpc name onto the controller with the given link ID.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TextLinkManager.MarkUpText(System.String)">
            <summary>
            Adds tooltip links to the text as appropriate.  This is an expensive operation.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TypeTooltipExtensions.UILinkGeneric(System.Object)">
            <summary> Generates a UILink for target object. </summary>
            <remarks> Automatically determines the way it should be linked based on its type and implemented interfaces. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.TextLinks.TypeTooltipExtensions.UILink(System.Type,System.Int32,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary> Generates a UILink for target type. </summary>
            <remarks> Assign the ID of the controller if linking an object of the type, or leave empty if linking the type itself. </remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.Tooltip.ParamExplanation.GetDescriptionRowForProperty(System.Type,System.Reflection.PropertyInfo,System.Object[])">
            <summary> Forms the list containing the display text of a row that describes a type's property. <para> Currently holds 'Icon + Name' on first index, and 'Description' (if any) on second index. </para> </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.Tooltip.ParamExplanation.DescribeObject(System.Object)">
            <summary> Determines the type of the object passed as parameter and describes it. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.Excludable">
            <summary> A category that can be excluded from tooltop generation. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.Includable">
            <summary> A category that can be included in tooltop generation. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.Controls">
            <summary> Tooltips that display controlls to the user. </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.TooltipContext">
            <summary>Context from the client used by tooltips</summary>
            <remarks>DEPRECATED in new tooltip system. Use User and TooltipOrigin instead.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Systems.Tooltip.TooltipSection.Cast(System.Object)">
            <summary> Casts <paramref name="value" /> to <see cref="T:Eco.Gameplay.Systems.Tooltip.TooltipSection" /> (if possible). </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.TooltipAttribute">
            <summary>
            Use on members of an <see cref="T:Eco.Core.Controller.IController" />.  Members with this attribute should return either a string or a <see cref="T:Eco.Gameplay.Systems.Tooltip.TooltipSection" />.
            Adds a section with the given content to this object's tooltip.  Sections will be displayed sorted by priority.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.TooltipTitleAttribute">
            <summary>
            Use on members of an <see cref="T:Eco.Core.Controller.IController" />.  Members with this attribute should return a string.
            Sets the title of this object's tooltip.  If multiple tooltip titles are found, only the one with the highest
            priority will be used.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Systems.Tooltip.TooltipChildrenAttribute">
            <summary>
            Use on members of an <see cref="T:Eco.Core.Controller.IController" />. Members with this attribute should return one or
            more <see cref="T:Eco.Core.Controller.IController" />s.  <see cref="T:Eco.Core.Controller.IController" />s returned by this member will have their
            tooltip members included along with this object's tooltip.  Adding a <see cref="P:Eco.Gameplay.Systems.Tooltip.TooltipChildrenAttribute.CategoriesToExclude" /> as a parameter
            to the attribute will filter tooltips of that type from the child(ren) for this object's tooltip.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditorUtils.PopupUserEditValue(Eco.Gameplay.Players.User,System.Type,Eco.Shared.Localization.LocString,System.Object,Eco.Core.Utils.PropertyScanning.IProvidesContext,System.Action{System.Object})">
            <summary>Static function to retrieve a GameValue of type T from the player via a dialog box.</summary>
        </member>
        <member name="M:Eco.Gameplay.Systems.ViewEditorUtils.PopupUserEditValueNoHolder(Eco.Gameplay.Players.User,System.Type,System.Nullable{Eco.Shared.Localization.LocString},Eco.Core.Controller.IController,System.Action{System.Object},Eco.Gameplay.Systems.ViewEditor.WindowType,System.Nullable{Eco.Shared.Localization.LocString})">
            <summary>Static function to edit entry itself, without holder.
            Note: rename of simple entry within this editor will rename existing object (because this will cause Registrar.Rename)</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.ClosestMatchingItem``1(Eco.Gameplay.Players.Player,System.String)">
            <summary> Get a matching item of the given type. If null is passed, get a random one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.ClosestMatchingEntity``1(Eco.Gameplay.Players.Player,System.String,System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.String},System.Func{``0,Eco.Shared.Localization.LocString},System.Predicate{``0})">
            <summary> Returns closest matching entities by <paramref name="entityName" /> from <paramref name="entityList" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.CheckPlayerOnline(Eco.Gameplay.Players.User,Eco.Gameplay.Players.User)">
            <summary>Check if a player is online before applying action and tell if not</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.CollectClosestMatchingEntries``1(Eco.Gameplay.Players.Player,System.String,System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.String},System.Func{``0,Eco.Shared.Localization.LocString},System.Predicate{``0})">
            <summary> Collects closest matching entries by <paramref name="entityName" /> from <paramref name="entityList" />. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CommandsUtil.CollectMatches``1(System.Collections.Generic.List{``0},System.String,System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.String},System.Func{``0,Eco.Shared.Localization.LocString},System.Func{System.String,System.String,System.Boolean})">
            <summary> Collects to <paramref name="container" /> all matches by <paramref name="entityName" /> from <paramref name="entityList" /> using <paramref name="matcher" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IRemovableEntry">
            <summary> Any entry that implement that should be able to remove it from its collection. By example can be used to remove directly entries from some registrar. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.VerifyAndSet(Eco.Gameplay.Players.Player,System.Collections.Generic.IEnumerable{System.Object},Eco.Core.Utils.IClientControlledContainer)">
            <summary> Verifies if the given list is valid and if so it will be set. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.Add(Eco.Gameplay.Players.Player,System.String)">
            <summary> Adds entry from registrar.
            The container and the entries are gotten from <paramref name="listName"></paramref>, then the container adds the <paramref name="player"></paramref> and each entry. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.RemoveAt(Eco.Gameplay.Players.Player,System.String,System.Int32)">
            <summary> Removes index from registrar.
            The container is gotten from <paramref name="listName"></paramref>, then the container removes the selected <paramref name="index"></paramref>  </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.Remove(Eco.Gameplay.Players.Player,System.String,Eco.Core.Controller.IController)">
            <summary> Removes entry from registrar. The container is gotten from <paramref name="listName"></paramref>,
            then the container removes the selected <paramref name="entry"></paramref>  </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.MoveRelative(Eco.Gameplay.Players.Player,System.String,Eco.Core.Controller.IController,System.Int32)">
            <summary> Moves entry. The container is gotten from <paramref name="listName"></paramref>, then the <paramref name="entry"></paramref> is shifted in the container
            <paramref name="iDeltaMove"></paramref> positions </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.Move(Eco.Gameplay.Players.Player,System.String,System.Int32,System.Int32)">
            <summary> Move entry. The container is gotten from <paramref name="listName"></paramref>, then the container Moves the selected <paramref name="iEntry"></paramref>
            to the <paramref name="newIndex"></paramref></summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.IHasClientControlledContainers.SetAt(Eco.Gameplay.Players.Player,System.String,System.Int32,Eco.Core.Controller.IController)">
            <summary> Replaces the existing entry of a list at given index. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.ControllerUtils.TypeID(Eco.Core.Controller.IController)">
            <summary>Given a controller, return the type ID that is stored in ViewClassInfo. The client can use this type id too.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.CountdownExtensions">
            <summary> Functions that modify immutable countdowns to return a new countdown. </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.CountdownExtensions.ResetAndPause(Eco.Shared.Utils.ImmutableCountdown)">
            <summary> Returns a new countdown with the same duration as the referenced one.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.DateTimeUtils.DateTimeFromString(System.String)">
            <summary>Take number from string as minutes and count a new date from current time.</summary>
            <param name="time">String should follow the template: 1m || 1h || 1d || 1w</param>
        </member>
        <member name="T:Eco.Gameplay.Utils.PopupEditAttribute">
            <summary>Tag properties with this to allow clients to call an 'EditProperty' RPC to open a popup that edits them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.Invitations.AcceptIfNotMember(System.String)">
            <summary>Accept incoming invitation and handle different states.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.Invitations.RemoveInvitationIfExists(System.String)">
            <summary>Reject incoming invitation and remove mail message.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.ItemTracker.ReduceRemainingStacks``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Reduces remaining stacks using <paramref name="maxRemainingStacks" />. After this call remaining stacks will only have items from <paramref name="maxRemainingStacks" /> and all quantities
            will be less or equal to quantities in <paramref name="maxRemainingStacks" />. If current quantity less than in <paramref name="maxRemainingStacks" /> then it will stay untouched.
            </summary>
            <returns>True if any of remaining stacks was modified.</returns>
        </member>
        <member name="M:Eco.Gameplay.Utils.ItemTracker.ContributedItem(System.Int32,Eco.Gameplay.Items.Item,Eco.Shared.Items.WorkOrderContributionType)">
            <summary>Calculate contributed item amount base on contribution type to prevent re-counting when AutoContributed contribution </summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.MessagingUtils.Notify(Eco.Gameplay.Interactions.InteractResult,Eco.Gameplay.Players.Player)">
            <summary>Message the user with the given interact result.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.MessagingUtils.NotifyError(Eco.Shared.Networking.INetClient,Eco.Shared.Localization.LocString)">
            <summary>Message the user with the given message in error format.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IDataPartition`1">
            <summary>This interface provides a minimalistic list interface and acts as a unified base for both the partitioned data and each individual data partition.</summary>
            <remarks>Used exclusively by <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" />. See <see cref="T:Eco.Gameplay.Utils.IStoredDataPartition`1" /> when looking to implement a data partition.</remarks>
        </member>
        <member name="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})">
            <summary>Removes all entries matching <paramref name="predicate" /> and returns number of removed entries.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.IStoredDataPartition`1">
            <summary>A minimalistic list interface with thread safe entries list for storage purposes.</summary>
            <remarks>Use this when implementing actual data partition for use with <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" />.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.IHasCreationTime">
            <summary>When creating an entity to be used with <see cref="T:Eco.Gameplay.Utils.PartitionedData`2" /> it needs to have a creation time entry
            to determine if a new data partition should be created alongside a new entry.</summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.PartitionedData`2">
            <summary>Partitioned data is used for high update frequency data such as Chat and Notifications. For each new day, a new data partition will be created and since each individual data partition
            is <see cref="T:Eco.Core.Serialization.IStorage" />, they are saved separately and that heavily enhances serialization speed, because only the active partition needs to be saved on updates as the previous ones are locked.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.LoadOrCreate(System.String)">
            <summary>Loads data from storage or creates new.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.GetOrAddPartition(System.Double)">
            <summary>Gets current partition if time within same day as last partition or creates new partition.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.AddNewPartition(System.Int64)">
            <summary>Adds new partition to end of <see cref="F:Eco.Gameplay.Utils.PartitionedData`2.partitionList" /> and sets it as <see cref="F:Eco.Gameplay.Utils.PartitionedData`2.activePartition" />.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.PartitionedData`2.RemoveAll(System.Predicate{`1})">
            <inheritdoc cref="M:Eco.Gameplay.Utils.IDataPartition`1.RemoveAll(System.Predicate{`0})" />
            <remarks>Removes entries from actual partitions by recursing the RemoveAll call into them.</remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.PickerObject">
            <summary> A picker that targets objects. Contract clauses use this to determine the target of their operation.</summary>
            <remarks> e.g.: "Put 10 Advanced Upgrade 2 to SomeUsers's Storage Chest". This is what's used to select "SomeUser's Storage Chest". </remarks>
        </member>
        <member name="T:Eco.Gameplay.Utils.PickerProperty">
            <summary> A picker that targets a property. Contract clauses use this to determine the target of their operation.</summary>
            <remarks> e.g.: "Gather 10 Tomatoes from SomeUserFarm". This is what's used to select "SomeUserFarm". </remarks>
        </member>
        <member name="M:Eco.Gameplay.Utils.ResultExtensions.NotifyError(Eco.Core.Utils.Result,Eco.Gameplay.Players.User)">
            <summary> If result is failed, notifies <paramref name="user" /> with failure message and with message style <see cref="F:Eco.Shared.Services.NotificationStyle.Error" />. </summary>
        </member>
        <member name="T:Eco.Gameplay.Utils.RouteManagerUtil">
            <summary>Route Manager helper methods specific to Eco.Gameplay.</summary>
        </member>
        <member name="M:Eco.Gameplay.Utils.RouteManagerUtil.TryGetNearestWalkableAreaWithoutFoliage(Eco.Shared.Math.WorldPosition3i,Eco.Shared.Math.WorldPosition3i@,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{Eco.Simulation.Agents.Plant,System.Boolean},System.Boolean)">
            <summary>
            Finds the nearest walkable area near startPos. Looks for an area without any adjacent foliage (Use predicate to add plants to skip).
            <para>If still no suitable area was found then pick a new spot and destroy all adjacent foliage if destroyPlants or destroyTrees is true.</para>
            </summary>
            <param name="startPos">The starting world position. If <see cref="M:Eco.Gameplay.Utils.RouteManagerUtil.TryGetNearestWalkableAreaWithoutFoliage(Eco.Shared.Math.WorldPosition3i,Eco.Shared.Math.WorldPosition3i@,System.Int32,System.Int32,System.Int32,System.Int32,System.Func{Eco.Simulation.Agents.Plant,System.Boolean},System.Boolean)" /> returns false then walkable will default to startPos.</param>
            <param name="walkable"></param>
            <param name="searchRadius">The radius in meters to search outwards from startPos.</param>
            <param name="safeRadius">The radius in meters required for a spawn point to be considered "suitable". Ie. Size of area with no foliage.</param>
            <param name="destroyPlantsRadius"></param>
            <param name="destroyTreesRadius"></param>
            <param name="plantPredicate">Condition to meet when comparing plants. Ie. Plants to skip when pathfinding. Ex. Add "plant.Species.Name.Equals("CommonGrass")" to skip grass when checking for plants.</param>
            <param name="clearTerrain">clears terrain around spawn point, won't destroy world objects</param>
        </member>
        <member name="M:Eco.Gameplay.Utils.RouteManagerUtil.DestroyPlantsWithinRadius(Eco.Shared.Math.WorldPosition3i,System.Int32)">
            <summary>
            Destroys all plants at position within radius with a top down projection.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Eco.Gameplay.Utils.RouteManagerUtil.DestroyTreesWithinRadius(Eco.Shared.Math.WorldPosition3i,System.Int32)">
            <summary>
            Destroys all trees at position within radius with a top down projection.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Eco.Gameplay.Utils.TestUtils.OtherUsers(System.Int32,System.Boolean)">
            <summary>Get an enumerable of test users, creating new ones as needed (or forcing only new ones if set to true)</summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialFood.GetDistinctedFoodInPosition(Eco.Shared.Math.Vector3)">
            <summary>Gets unique and alive closest to position</summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialTasks.EnsureUIState(Eco.Gameplay.Players.User,System.String,System.String)">
            <summary>
            For some unknown reason sometimes tutorial sequence fails and user may be left with incorrect UI state.
            Until we be 100% sure it works stable we have to check UIState and re-add these tasks to avoid breaking the game.
            https://github.com/StrangeLoopGames/EcoIssues/issues/9020.
            </summary>
            <param name="user">user.</param>
            <param name="taskTitle">corresponding task title.</param>
            <param name="uiStateName">state name to check.</param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialTasks.TrySubscribeTutorials(Eco.Gameplay.Players.User)">
            <summary>Setup tutorials to trigger activation on specific events.</summary>
            <param name="user"></param>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.UserSubTaskCarvePath">
            <summary> Task for following player's progress towards carving path around (as example, learning machete) </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserSubTaskCarvePath.IsComplete(Eco.Simulation.Agents.Plant,System.Object)">
            <summary> Decrement plants count until zero and pass when selected required tool </summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.UserSubTaskTooltipOpened">
            <summary> Completes once the player opens a tooltip that derived from ItemType /// </summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.TutorialStatus">
            <summary> Watching system for the tutorial. The flags indicate the client what RPCs are needed </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialStatus.Add(Eco.Shared.Items.TutorialFlag)">
            <summary> Adds <paramref name="flag" /> to the current flags and update the client information </summary>
            <param name="flag">Flag to include</param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.TutorialStatus.Remove(Eco.Shared.Items.TutorialFlag)">
            <summary> Removes <paramref name="flag" /> from the current flags and update the client information </summary>
            <param name="flag">Flag to remove</param>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTask.SetUIStates">
            <summary>Turn on states that this task enables, like showing the food panel when the food ui starts.</summary>
        </member>
        <member name="T:Eco.Gameplay.Tutorial.UserTaskManager">
            <summary>Class for handling the tasks (so far just tutorials) that an individual user is given. Manages the creation, tracking, 
            ordering, etc of them.</summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTaskManager.SetTaskDisplayPosition(Eco.Gameplay.Tutorial.UserTask)">
            <summary> sets task order display by discovery order </summary>
        </member>
        <member name="M:Eco.Gameplay.Tutorial.UserTaskManager.ActivateChainedTasks(Eco.Gameplay.Tutorial.UserTask)">
            <summary>When a task completes, call this to activate everything its chained to.</summary>
        </member>
        <member name="T:Eco.Gameplay.UI.ButtonList">
            <summary>Display a list of entries with a custom titled and colored button optionally displayed for each.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.ButtonList.Set(System.Collections.Generic.IList{Eco.Shared.UI.ButtonListEntry})">
            <summary>Set the entries and buttons for this list, clearing the old list.</summary>
        </member>
        <member name="M:Eco.Gameplay.UI.PlayerPopups.OptionBox(Eco.Gameplay.Players.Player,Eco.Shared.Localization.LocString,System.Collections.Generic.List{System.String})">
            <summary>Shows a dialog with a dropdown.</summary>
            <param name="player"></param>
            <param name="message">The text to be shown.</param>
            <param name="options">Options to be added to the dropdown.</param>
            <returns>Index of the selected item. -1 if the player cancells the dialog.</returns>
        </member>
        <member name="T:Eco.Gameplay.UI.Roster">
            <summary>A roster maintains a list of users in which both the owner of the list and the user being added need to approve.  It tracks
            a set of members (externally defined), a set of applicants, and a set of invitees.
            This is used for membership requirements like residency, classrooms, and citizenship.</summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.ReplaceTerrain(System.Type,Eco.Shared.Math.WorldPosition3i,System.Int32,System.Type,System.Boolean)">
            <summary> Replace terrain blocks on a certain block type. Works only for top blocks </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnList(Eco.Gameplay.Players.User,System.Collections.Generic.List{System.String},Eco.Gameplay.WorldObjectDebugUtil.DeluxeSpawnFlags,System.Int32)">
            <summary> Function for spawning a list of WorldObjects on User's position. </summary>
        </member>
        <member name="M:Eco.Gameplay.WorldObjectDebugUtil.SpawnList(Eco.Gameplay.Players.User,Eco.Shared.Math.Vector3i,System.Collections.Generic.List{System.String},Eco.Gameplay.WorldObjectDebugUtil.DeluxeSpawnFlags,System.Int32)">
            <summary> Function for spawning a list of WorldObjects in a custom position.</summary>
            <remarks> Calculates size first, and returns it together with a Func that confirms the spawning. </remarks>
        </member>
        <member name="T:Eco.Gameplay.Voice.VivoxAccessToken">
            <summary>
            Class used to serialise the vivox access token.
            </summary>
        </member>
        <member name="T:Eco.Gameplay.Voice.VoiceAudioFadeModel">
            <summary>
            Vivox audio fade model for 3D audio channels (positional voice). Default is InverseByDistance.
            </summary>
        </member>
        <member name="M:Eco.Gameplay.Voice.VoiceManager.UpdateClusters">
            <summary>
            This function works the fact that game world space loops but Vivox does not. It creates clusters of players
            that can possibly hear each other, which then get offset by the client.
            </summary>
        </member>
        <member name="M:Eco.Core.Systems.UnserializedNamedEntry`1.Clear">
            <summary> Clears all entries. It isn't thread-safe for same entity type, but thread safe with other <see cref="T:Eco.Core.Systems.UnserializedNamedEntry" />.</summary>
        </member>
        <member name="P:Eco.Core.Utils.PropertyScanning.ICustomValidity.SkipPropertyValidation">
            <summary>If true, only the implementing objects Validity will be checked. If false, all properties will be validated and report added to result (default behavior).
            Is used in Demographics to ignore validity of props for Special Demographics as they are statically set up and cannot change.</summary>
        </member>
        <member name="T:Eco.Core.Utils.PropertyScanning.IReferrerDependentValidity">
            <summary>Defines a validity to be used when item is referenced by something else.</summary>
        </member>
        <member name="M:Eco.Core.Utils.PropertyScanning.IReferrerDependentValidity.Valid(System.Type,System.Type)">
            <summary>
            Check if valid for types that referer to this item.
            </summary>
            <param name="referrerType">The immediate parent of the item.</param>
            <param name="referrerRootType">The root object this item belongs to.</param>
        </member>
        <member name="T:Eco.Core.Utils.PropertyScanning.PropertyScanner">
            <summary>PropertyScanner that does a scan on an object, using reflection to examine and update its properties.  It can do the following things:
            - Detect if the object is valid, using attributes like [AllowNull] and others to help it determine what is valid or not. 
            - Caches validity if has the ICachesValidity interface. Returns the Result.
            - Returns paths of all the properties that were invalid, which allows the client to display markers and text on them. 
            - Updates tracked references and referenced-by, which are stored in  ker.
            - Fixes parameters referencing bad context 
            - Can apply reference updating (when an object gets swapped for another, modified through election for example).
            - Sets up any instances of IParentedController it finds, configuring the hierarchy.
            </summary>
        </member>
    </members>
</doc>
